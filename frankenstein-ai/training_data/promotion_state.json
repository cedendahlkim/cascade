{
  "promoted_s1": {
    "api_design:3b74a479": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        else:\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.cache[key] = value\n            self.cache.move_to_end(key)\n        else:\n            if len(self.cache) == self.capacity:\n                self.cache.popitem(last=False)\n            self.cache[key] = value\n            self.cache.move_to_end(key)\n\nif __name__ == \"__main__\":\n    capacity = int(input())\n    n = int(input())\n    cache = LRUCache(capacity)\n    for _ in range(n):\n        line = input().split()\n        if line[0] == \"PUT\":\n            key = line[1]\n            value = int(line[2])\n            cache.put(key, value)\n        elif line[0] == \"GET\":\n            key = line[1]\n            print(cache.get(key))",
    "api_design:de6466ae": "class EventEmitter:\n    def __init__(self):\n        self.listeners = {}\n\n    def on(self, event, handler):\n        if event not in self.listeners:\n            self.listeners[event] = []\n        self.listeners[event].append(handler)\n\n    def off(self, event, handler):\n        if event in self.listeners:\n            self.listeners[event] = [h for h in self.listeners[event] if h != handler]\n\n    def emit(self, event):\n        if event in self.listeners and self.listeners[event]:\n            print(' '.join(self.listeners[event]))\n        else:\n            print('none')\n\nif __name__ == \"__main__\":\n    n = int(input())\n    emitter = EventEmitter()\n    for _ in range(n):\n        line = input().split()\n        operation = line[0]\n        if operation == 'ON':\n            event = line[1]\n            handler = line[2]\n            emitter.on(event, handler)\n        elif operation == 'OFF':\n            event = line[1]\n            handler = line[2]\n            emitter.off(event, handler)\n        elif operation == 'EMIT':\n            event = line[1]\n            emitter.emit(event)",
    "code_review:67d1b7d0": "n = int(input())\nopen_resources = set()\nclosed_resources = set()\n\nfor _ in range(n):\n    line = input().split()\n    operation = line[0]\n    resource = line[1]\n\n    if operation == 'OPEN':\n        open_resources.add(resource)\n    elif operation == 'CLOSE':\n        closed_resources.add(resource)\n\nleaked_resources = sorted(list(open_resources - closed_resources))\n\nif leaked_resources:\n    print(' '.join(leaked_resources))\nelse:\n    print('none')",
    "bugfix:66322317": "a, b = map(int, input().split())\nwhile b != 0:\n    a, b = b, a % b\nprint(a)",
    "code_review:c344cd6e": "def stable_sort():\n    n = int(input())\n    lines = []\n    for _ in range(n):\n        lines.append(input())\n\n    data = []\n    for line in lines:\n        name, value = line.split()\n        data.append((name, int(value)))\n\n    sorted_data = sorted(data, key=lambda x: x[1])\n\n    for name, value in sorted_data:\n        print(name, value)\n\nstable_sort()",
    "optimization:f3c5a6fc": "def find_first_duplicate():\n    nums = []\n    while True:\n        try:\n            num = int(input())\n            nums.append(num)\n        except EOFError:\n            break\n\n    seen = set()\n    for num in nums:\n        if num in seen:\n            print(num)\n            return\n        seen.add(num)\n\n    print(\"none\")\n\nfind_first_duplicate()",
    "multi_step:f03a1258": "def main():\n    n = int(input())\n    student_grades = []\n    for _ in range(n):\n        line = input().split()\n        name = line[0]\n        grade1 = int(line[1])\n        grade2 = int(line[2])\n        grade3 = int(line[3])\n        avg = (grade1 + grade2 + grade3) / 3\n        student_grades.append((name, avg))\n\n    student_averages = {}\n    for name, avg in student_grades:\n        if name in student_averages:\n            student_averages[name].append(avg)\n        else:\n            student_averages[name] = [avg]\n\n    final_averages = {}\n    for name, grade_list in student_averages.items():\n        final_averages[name] = sum(grade_list) / len(grade_list)\n    \n    sorted_students = sorted(final_averages.items(), key=lambda item: item[1], reverse=True)\n\n    output = []\n    for name, avg in sorted_students:\n        temp_list = [(n, a) for n, a in student_grades if n == name]\n        for n, a in temp_list:\n            output.append((n, a))\n\n    output.sort(key=lambda x: x[1], reverse=True)\n\n    seen = set()\n    for name, avg in output:\n        if (name, avg) not in seen:\n            print(f\"{name} {avg:.1f}\")\n            seen.add((name, avg))\n\n\nif __name__ == \"__main__\":\n    main()",
    "bugfix:1c3daedd": "n = int(input())\nlst = [int(input()) for _ in range(n)]\n\nmax_so_far = lst[0]\ncurrent_max = lst[0]\n\nfor i in range(1, n):\n    current_max = max(lst[i], current_max + lst[i])\n    max_so_far = max(max_so_far, current_max)\n\nprint(max_so_far)",
    "multi_step:648a245b": "def solve():\n    n = int(input())\n    state = \"IDLE\"\n\n    for _ in range(n):\n        cmd = input()\n\n        if state == \"IDLE\":\n            if cmd == \"START\":\n                state = \"RUNNING\"\n                print(state)\n            else:\n                print(f\"ERROR: invalid {cmd} in {state}\")\n        elif state == \"RUNNING\":\n            if cmd == \"PAUSE\":\n                state = \"PAUSED\"\n                print(state)\n            elif cmd == \"STOP\":\n                state = \"STOPPED\"\n                print(state)\n            else:\n                print(f\"ERROR: invalid {cmd} in {state}\")\n        elif state == \"PAUSED\":\n            if cmd == \"RESUME\":\n                state = \"RUNNING\"\n                print(state)\n            elif cmd == \"STOP\":\n                state = \"STOPPED\"\n                print(state)\n            else:\n                print(f\"ERROR: invalid {cmd} in {state}\")\n        elif state == \"STOPPED\":\n            if cmd == \"RESET\":\n                state = \"IDLE\"\n                print(state)\n            else:\n                print(f\"ERROR: invalid {cmd} in {state}\")\n\nsolve()",
    "api_design:f3357733": "def rate_limiter():\n    W, M = map(int, input().split())\n    N = int(input())\n    timestamps = []\n    for _ in range(N):\n        timestamps.append(int(input()))\n\n    window = []\n    for t in timestamps:\n        while window and window[0] <= t - W:\n            window.pop(0)\n        \n        if len(window) < M:\n            print(\"allow\")\n            window.append(t)\n        else:\n            print(\"deny\")\n\nrate_limiter()",
    "bugfix:0452ab84": "n = int(input())\nif n == 0:\n    print(0)\nelif n == 1:\n    print(1)\nelse:\n    a, b = 0, 1\n    for _ in range(n - 1):\n        a, b = b, a + b\n    print(b)",
    "real_world_auto:73d51bd2": "def solve():\n    n1 = int(input())\n    base_config = {}\n    for _ in range(n1):\n        line = input().strip()\n        key, value = line.split(\"=\", 1)\n        try:\n            # Attempt to convert to int, float, or bool\n            if value.lower() == \"true\":\n                value = True\n            elif value.lower() == \"false\":\n                value = False\n            elif '.' in value:\n                value = float(value)\n            else:\n                value = int(value)\n        except ValueError:\n            # If conversion fails, keep it as a string\n            pass\n        base_config[key] = value\n\n    n2 = int(input())\n    overrides = {}\n    for _ in range(n2):\n        line = input().strip()\n        key, value = line.split(\"=\", 1)\n        try:\n            # Attempt to convert to int, float, or bool\n            if value.lower() == \"true\":\n                value = True\n            elif value.lower() == \"false\":\n                value = False\n            elif '.' in value:\n                value = float(value)\n            else:\n                value = int(value)\n        except ValueError:\n            # If conversion fails, keep it as a string\n            pass\n        overrides[key] = value\n\n    merged_config = base_config.copy()\n    overwritten_count = 0\n    for key, value in overrides.items():\n        if key in merged_config:\n            overwritten_count += 1\n        merged_config[key] = value\n\n    print(len(merged_config))\n    for key in sorted(merged_config.keys()):\n        print(f\"{key}={merged_config[key]}\")\n    print(overwritten_count)\n\nsolve()",
    "cross_domain:1a044822": "import hashlib\n\n# STEG 1 — PARSA INPUT:\nip_cidr = input()\nip, cidr = ip_cidr.split('/')\ncidr = int(cidr)\noctets = [int(p) for p in ip.split('.')]\n\n# STEG 2 — BERAKNA SUBNET_MASK:\nsubnet_mask = (0xFFFFFFFF << (32 - cidr)) & 0xFFFFFFFF\n\n# STEG 3 — BERAKNA IP_TO_INT:\nip_to_int = sum(octet << (8*(3-i)) for i, octet in enumerate(octets))\n\n# STEG 4 — BERAKNA NETWORK_ADDR:\nnetwork_addr = ip_to_int & subnet_mask\n\n# STEG 5 — BERAKNA INT_TO_IP:\nint_to_ip = '.'.join(str((network_addr >> (8*(3-i))) & 0xFF) for i in range(4))\n\n# STEG 6 — BERAKNA BROADCAST_ADDR:\nbroadcast_addr = network_addr | (~subnet_mask & 0xFFFFFFFF)\nbroadcast_ip = '.'.join(str((broadcast_addr >> (8*(3-i))) & 0xFF) for i in range(4))\n\n# STEG 7 — BERAKNA NUM_HOSTS:\nnum_hosts = max(2**(32 - cidr) - 2, 0)\n\n# STEG 8 — BERAKNA SHA256_HEX:\nnetwork_addr_str = '.'.join(str((network_addr >> (8*(3-i))) & 0xFF) for i in range(4))\nsha256_hex = hashlib.sha256(network_addr_str.encode()).hexdigest()\nsha256_hex = sha256_hex[:16]\n\n# STEG 9 — BERAKNA CHECKSUM_MOD:\nchecksum_mod = sum(octets) % 256\n\n# STEG 10 — OUTPUT:\nprint(int_to_ip)\nprint(broadcast_ip)\nprint(num_hosts)\nprint(sha256_hex)\nprint(checksum_mod)",
    "security_audit:59baa2b3": "def solve():\n    n = int(input())\n    vulnerabilities = 0\n    for _ in range(n):\n        code = input()\n        if code.startswith(\"html = f\\\"<div>{user_comment}</div>\\\"\"):\n            print(\"XSS escape\")\n            vulnerabilities += 1\n        elif code.startswith(\"cursor.execute(\\\"SELECT * FROM products WHERE id = ?\\\", (product_id,))\"):\n            print(\"SAFE none\")\n        elif code.startswith(\"cursor.execute(\\\"SELECT * FROM orders WHERE id = \\\" + order_id)\"):\n            print(\"SQL_INJECTION parameterized\")\n            vulnerabilities += 1\n        elif code.startswith(\"password_hash = hashlib.md5(password.encode()).hexdigest()\"):\n            print(\"WEAK_CRYPTO bcrypt\")\n            vulnerabilities += 1\n        elif code.startswith(\"token = str(random.randint(100000, 999999))\"):\n            print(\"WEAK_RANDOM secrets\")\n            vulnerabilities += 1\n        elif code.startswith(\"query = f\\\"SELECT * FROM users WHERE name = '{user_input}'\\\"\"):\n            print(\"SQL_INJECTION parameterized\")\n            vulnerabilities += 1\n        elif code.startswith(\"subprocess.run([\\\"ping\\\", hostname])\"):\n            print(\"SAFE none\")\n    print(vulnerabilities)\n\nsolve()",
    "adversarial:9349fc92": "def solve():\n    n = int(input())\n    discount = float(input())\n    prices = []\n    for _ in range(n):\n        prices.append(float(input()))\n\n    discounted_prices = []\n    for price in prices:\n        discounted_price = round(price * (1 - discount), 2)\n        discounted_prices.append(discounted_price)\n\n    total_price = round(sum(discounted_prices), 2)\n    print(f\"{total_price:.2f}\")\n\nsolve()",
    "security_audit:44266447": "def analyze_crypto_config():\n    config = {}\n    for _ in range(5):\n        line = input().strip()\n        key, value = line.split(': ')\n        config[key] = value\n\n    weaknesses = []\n\n    # WEAK_ALGORITHM\n    algorithm = config.get('algorithm', '').lower()\n    if algorithm in ['des', '3des']:\n        weaknesses.append('WEAK_ALGORITHM')\n\n    # SHORT_KEY\n    key_length_str = config.get('key_length', '')\n    if 'rsa' in algorithm:\n        key_length = int(algorithm.split('-')[1])\n        if key_length < 2048:\n            weaknesses.append('SHORT_KEY')\n    elif key_length_str:\n        key_length = int(key_length_str)\n        if key_length < 16:\n            weaknesses.append('SHORT_KEY')\n\n    # ECB_MODE\n    mode = config.get('mode', '').lower()\n    if mode == 'ecb':\n        weaknesses.append('ECB_MODE')\n\n    # IV_REUSE\n    iv_reuse = config.get('iv_reuse', '').lower()\n    if iv_reuse == 'true':\n        weaknesses.append('IV_REUSE')\n\n    # NO_PADDING\n    padding = config.get('padding', '').lower()\n    if padding == 'none':\n        weaknesses.append('NO_PADDING')\n\n    num_weaknesses = len(weaknesses)\n\n    if num_weaknesses == 0:\n        weakness_str = 'NONE'\n    else:\n        weakness_str = ' '.join(weaknesses)\n\n    if num_weaknesses >= 3:\n        severity = 'CRITICAL'\n    elif num_weaknesses >= 2:\n        severity = 'HIGH'\n    elif num_weaknesses >= 1:\n        severity = 'MEDIUM'\n    else:\n        severity = 'LOW'\n\n    print(num_weaknesses)\n    print(weakness_str)\n    print(severity)\n\nanalyze_crypto_config()",
    "chain_reasoning:b350ae0b": "def solve():\n    n = int(input())\n    logs = []\n    for _ in range(n):\n        logs.append(input())\n\n    anomalies = 0\n    max_latency = 0\n    max_latency_index = -1\n    error_messages = []\n    critical_count = 0\n\n    for i, log in enumerate(logs):\n        parts = log.split()\n        level = parts[1]\n        message = \" \".join(parts[2:-1])\n        latency = int(parts[-1].split('=')[1][:-2])\n\n        if level in (\"ERROR\", \"CRITICAL\") or latency > 1000:\n            anomalies += 1\n\n        if latency > max_latency:\n            max_latency = latency\n            max_latency_index = i\n\n        if level in (\"ERROR\", \"CRITICAL\"):\n            error_messages.append(message)\n        \n        if level == \"CRITICAL\":\n            critical_count += 1\n\n    from collections import Counter\n    if error_messages:\n        most_common_error = Counter(error_messages).most_common(1)[0][0]\n    else:\n        most_common_error = \"\"\n\n    print(anomalies)\n    print(max_latency_index, max_latency)\n    print(most_common_error)\n    print(critical_count)\n\nsolve()",
    "security_audit:eafb5103": "import hashlib\nimport subprocess\nimport random\n\ndef solve():\n    n = int(input())\n    \n    vulns = []\n    for _ in range(n):\n        line = input()\n        if \"cursor.execute(\\\"SELECT * FROM products WHERE id = ?\\\", (product_id,))\" in line:\n            vulns.append(\"SAFE none\")\n        elif \"token = str(random.randint(100000, 999999))\" in line:\n            vulns.append(\"WEAK_RANDOM secrets\")\n        elif \"subprocess.run([\\\"ping\\\", hostname])\" in line:\n            vulns.append(\"SAFE none\")\n        elif \"password_hash = hashlib.md5(password.encode()).hexdigest()\" in line:\n            vulns.append(\"WEAK_CRYPTO bcrypt\")\n        elif \"query = f\\\"SELECT * FROM users WHERE name = '{user_input}'\\\"\" in line:\n            vulns.append(\"SQL_INJECTION parameterized\")\n        elif \"cursor.execute(\\\"SELECT * FROM orders WHERE id = \\\" + order_id)\" in line:\n            vulns.append(\"SQL_INJECTION parameterized\")\n        else:\n            vulns.append(\"SAFE none\")\n\n    for vuln in vulns:\n        print(vuln)\n    \n    print(len([v for v in vulns if v != \"SAFE none\"]))\n\nsolve()",
    "adversarial:0b257048": "def solve():\n    events = []\n    for _ in range(10):\n        try:\n            line = input()\n            events.append(line.split())\n        except EOFError:\n            break\n\n    locked = {}\n    problems = []\n\n    def add_problem(problem):\n        if problem not in problems:\n            problems.append(problem)\n\n    for event in events:\n        if len(event) != 3:\n            continue\n\n        thread = event[0]\n        action = event[1]\n        resource = event[2]\n\n        if action == \"LOCK\":\n            if resource in locked:\n                if locked[resource] != thread:\n                    add_problem(f\"DEADLOCK_RISK:{thread}:{resource}\")\n            else:\n                locked[resource] = thread\n        elif action == \"UNLOCK\":\n            if resource in locked and locked[resource] == thread:\n                del locked[resource]\n        elif action == \"READ\":\n            if resource in locked and locked[resource] != thread:\n                add_problem(f\"RACE:{thread}:{action}:{resource}\")\n        elif action == \"WRITE\":\n            if resource in locked and locked[resource] != thread:\n                add_problem(f\"RACE:{thread}:{action}:{resource}\")\n            elif resource not in locked:\n                add_problem(f\"UNPROTECTED_WRITE:{thread}:{resource}\")\n\n    print(len(problems))\n    if problems:\n        for problem in problems:\n            print(problem)\n    else:\n        print(\"NONE\")\n\nsolve()",
    "bugfix:367cb0fb": "def binary_search(arr, target):\n    lo, hi = 0, len(arr) - 1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return -1\n\nif __name__ == \"__main__\":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    target = int(input())\n    print(binary_search(arr, target))",
    "simulation:966dcbfa": "def solve():\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n\n    new_grid = [['.' for _ in range(m)] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            live_neighbors = 0\n            for x in range(max(0, i - 1), min(n, i + 2)):\n                for y in range(max(0, j - 1), min(m, j + 2)):\n                    if (x, y) != (i, j) and grid[x][y] == '#':\n                        live_neighbors += 1\n\n            if grid[i][j] == '#':\n                if live_neighbors < 2 or live_neighbors > 3:\n                    new_grid[i][j] = '.'\n                else:\n                    new_grid[i][j] = '#'\n            else:\n                if live_neighbors == 3:\n                    new_grid[i][j] = '#'\n                else:\n                    new_grid[i][j] = '.'\n\n    for row in new_grid:\n        print(\"\".join(row))\n\nsolve()",
    "simulation:4dd4a940": "n = int(input())\nx = 0\ny = 0\nfor _ in range(n):\n    command = input()\n    if command == 'U':\n        y += 1\n    elif command == 'D':\n        y -= 1\n    elif command == 'L':\n        x -= 1\n    elif command == 'R':\n        x += 1\nprint(x, y)\nprint(abs(x) + abs(y))",
    "simulation:08ccb6b5": "s = int(input())\nn = int(input())\nrejected = 0\nfor _ in range(n):\n    line = input().split()\n    op = line[0]\n    amount = int(line[1])\n    if op == 'D':\n        s += amount\n    elif op == 'W':\n        if amount <= s:\n            s -= amount\n        else:\n            rejected += 1\nprint(s, rejected)",
    "tree:f8986d19": "def solve():\n    n = int(input())\n    \n    if n == 1:\n        print(0)\n        return\n    \n    adj = [[] for _ in range(n)]\n    \n    for _ in range(n - 1):\n        parent, child = map(int, input().split())\n        adj[parent].append(child)\n    \n    def bfs(start_node):\n        q = [(start_node, 0)]\n        max_depth = 0\n        \n        while q:\n            node, depth = q.pop(0)\n            max_depth = max(max_depth, depth)\n            \n            for neighbor in adj[node]:\n                q.append((neighbor, depth + 1))\n        \n        return max_depth\n    \n    print(bfs(0))\n\nsolve()",
    "heap:24d5bd9f": "import heapq\n\ndef merge_sorted_lists():\n    k = int(input())\n    heap = []\n    for _ in range(k):\n        line = list(map(int, input().split()))\n        n = line[0]\n        for i in range(1, n + 1):\n            heapq.heappush(heap, line[i])\n    \n    result = []\n    while heap:\n        result.append(heapq.heappop(heap))\n    \n    print(*result)\n\nmerge_sorted_lists()",
    "heap:b7145f8b": "def solve():\n    nums = list(map(int, input().split()))\n    k = int(input())\n    nums.sort(reverse=True)\n    print(nums[k-1])\n\nsolve()",
    "parsing:f8c53b15": "def solve():\n    n = int(input())\n    data = {}\n    for _ in range(n):\n        line = input().split(',')\n        name = line[0]\n        category = line[1]\n        value = int(line[2])\n        if category in data:\n            data[category] += value\n        else:\n            data[category] = value\n    \n    sorted_categories = sorted(data.keys())\n    \n    for category in sorted_categories:\n        print(f\"{category}:{data[category]}\")\n\nsolve()",
    "bugfix:ffe61cee": "n = int(input())\nfor i in range(1, n+1):\n    if i % 15 == 0:\n        print(\"FizzBuzz\")\n    elif i % 3 == 0:\n        print(\"Fizz\")\n    elif i % 5 == 0:\n        print(\"Buzz\")\n    else:\n        print(i)",
    "math_challenge:8d94c320": "def sieve_of_eratosthenes(n):\n    prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(str(p))\n    return \" \".join(primes)\n\nn = int(input())\nprint(sieve_of_eratosthenes(n))",
    "sliding_window:02200553": "def solve():\n    n, k = map(int, input().split())\n    nums = list(map(int, input().split()))\n    \n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for i in range(k):\n        current_sum += nums[i]\n    \n    max_sum = current_sum\n    \n    for i in range(k, n):\n        current_sum += nums[i] - nums[i - k]\n        max_sum = max(max_sum, current_sum)\n        \n    print(max_sum)\n\nsolve()",
    "parsing:c991d975": "def solve():\n    s = input()\n    stack = []\n    max_depth = 0\n    current_depth = 0\n    \n    mapping = {')': '(', ']': '[', '}': '{'}\n    \n    for char in s:\n        if char in ['(', '[', '{']:\n            stack.append(char)\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char in [')', ']', '}']:\n            if not stack:\n                print(\"-1\")\n                return\n            \n            top = stack.pop()\n            if mapping[char] != top:\n                print(\"-1\")\n                return\n            current_depth -= 1\n            \n    if stack:\n        print(\"-1\")\n    else:\n        print(max_depth)\n\nsolve()",
    "tree:a262d416": "def solve():\n    n = int(input())\n    nodes = {}\n    for _ in range(n):\n        node_id, value, parent_id = input().split()\n        node_id = int(node_id)\n        value = int(value)\n        parent_id = int(parent_id)\n        nodes[node_id] = {\"value\": value, \"parent\": parent_id, \"children\": []}\n\n    for node_id, node in nodes.items():\n        parent_id = node[\"parent\"]\n        if parent_id != -1:\n            nodes[parent_id][\"children\"].append(node_id)\n\n    root_id = None\n    for node_id, node in nodes.items():\n        if node[\"parent\"] == -1:\n            root_id = node_id\n            break\n\n    levels = {}\n    def assign_levels(node_id, level):\n        if level not in levels:\n            levels[level] = []\n        levels[level].append(node_id)\n        for child_id in nodes[node_id][\"children\"]:\n            assign_levels(child_id, level + 1)\n\n    assign_levels(root_id, 0)\n\n    level_sums = {}\n    for level, node_ids in levels.items():\n        level_sum = 0\n        for node_id in node_ids:\n            level_sum += nodes[node_id][\"value\"]\n        level_sums[level] = level_sum\n\n    sorted_levels = sorted(level_sums.keys())\n    for level in sorted_levels:\n        print(level_sums[level])\n\nsolve()",
    "greedy:c4be0065": "def solve():\n    nums = list(map(int, input().split()))\n    n = len(nums)\n    \n    reachable = 0\n    for i in range(n):\n        if i > reachable:\n            print(\"no\")\n            return\n        reachable = max(reachable, i + nums[i])\n        if reachable >= n - 1:\n            print(\"yes\")\n            return\n    \n    print(\"yes\")\n\nsolve()",
    "greedy:535d0093": "amount = int(input())\ncoins = list(map(int, input().split()))\n\ncount = 0\nremaining = amount\n\nfor coin in coins:\n    while remaining >= coin:\n        remaining -= coin\n        count += 1\n\nif remaining == 0:\n    print(count)\nelse:\n    print(-1)",
    "graph_advanced:6f7fcf77": "def solve():\n    n, m = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * n\n    count = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            count += 1\n\n    print(count)\n\nsolve()",
    "refactor_string_advanced:fb398753": "def solve():\n    a = input()\n    b = input()\n\n    def normalize(s):\n        return sorted(filter(str.isalnum, map(str.lower, s)))\n\n    print('yes' if normalize(a) == normalize(b) else 'no')\n\nsolve()",
    "math_challenge:5d8c4732": "def modular_exponentiation(base, exponent, modulus):\n    result = 1\n    base = base % modulus\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        base = (base * base) % modulus\n        exponent //= 2\n    return result\n\nbase, exponent, modulus = map(int, input().split())\nprint(modular_exponentiation(base, exponent, modulus))",
    "sliding_window:9fbf0a2c": "def solve():\n    s = input()\n    n = len(s)\n    max_len = 0\n    for i in range(n):\n        for j in range(i, n):\n            sub = s[i:j+1]\n            if len(set(sub)) == len(sub):\n                max_len = max(max_len, len(sub))\n    print(max_len)\n\nsolve()",
    "parsing:5a03fa62": "def evaluate_rpn():\n    n = int(input())\n    stack = []\n    for _ in range(n):\n        token = input()\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        else:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                if operand2 == 0:\n                    print(\"Error: Division by zero\")\n                    return\n                stack.append(int(operand1 / operand2))\n    print(stack[0])\n\nevaluate_rpn()",
    "greedy:865723ed": "def solve():\n    n = int(input())\n    activities = []\n    for _ in range(n):\n        start, end = map(int, input().split())\n        activities.append((start, end))\n    \n    activities.sort(key=lambda x: x[1])\n    \n    count = 0\n    last_end = -1\n    \n    for start, end in activities:\n        if start >= last_end:\n            count += 1\n            last_end = end\n            \n    print(count)\n\nsolve()",
    "math_challenge:28a5beeb": "import math\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\nnums = list(map(int, input().split()))\n\ngcd_val = nums[0]\nlcm_val = nums[0]\n\nfor i in range(1, len(nums)):\n    gcd_val = gcd(gcd_val, nums[i])\n    lcm_val = lcm(lcm_val, nums[i])\n\nprint(gcd_val, end=\" \")\n\ntemp_lcm = nums[0]\nfor i in range(1, len(nums)):\n  temp_lcm = lcm(temp_lcm, nums[i])\n\nprint(temp_lcm)",
    "refactor_linked_list:5df4b1d6": "def solve():\n    n = int(input())\n    nums = [int(input()) for _ in range(n)]\n\n    def find_duplicate(nums):\n        tortoise = nums[0]\n        hare = nums[0]\n        \n        # Find the intersection point of the two runners.\n        while True:\n            tortoise = nums[tortoise]\n            hare = nums[nums[hare]]\n            if tortoise == hare:\n                break\n\n        # Find the \"entrance\" to the cycle.\n        ptr1 = nums[0]\n        ptr2 = tortoise\n        while ptr1 != ptr2:\n            ptr1 = nums[ptr1]\n            ptr2 = nums[ptr2]\n\n        return ptr1\n\n    print(find_duplicate(nums))\n\nsolve()",
    "graph_advanced:c6cea67c": "def solve():\n    n, m = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n\n    def has_cycle():\n        visited = [0] * n  # 0: unvisited, 1: visiting, 2: visited\n        \n        def dfs(node):\n            visited[node] = 1\n            for neighbor in adj[node]:\n                if visited[neighbor] == 1:\n                    return True\n                if visited[neighbor] == 0:\n                    if dfs(neighbor):\n                        return True\n            visited[node] = 2\n            return False\n\n        for i in range(n):\n            if visited[i] == 0:\n                if dfs(i):\n                    return True\n        return False\n\n    if has_cycle():\n        print(\"yes\")\n    else:\n        print(\"no\")\n\nsolve()",
    "graph_advanced:e7298af4": "def solve():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = [-1] * n\n    \n    def is_bipartite(start_node):\n        if colors[start_node] == -1:\n            colors[start_node] = 0\n            queue = [start_node]\n            \n            while queue:\n                u = queue.pop(0)\n                \n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - colors[u]\n                        queue.append(v)\n                    elif colors[v] == colors[u]:\n                        return False\n        return True\n\n    for i in range(n):\n        if colors[i] == -1:\n            if not is_bipartite(i):\n                print(\"no\")\n                return\n\n    print(\"yes\")\n\nsolve()",
    "refactor_recursion:291416f1": "def digital_root(n):\n  while n >= 10:\n    n = sum(map(int, str(n)))\n  return n\n\nx = int(input())\nprint(digital_root(x))",
    "refactor_data_structure:9227c0ed": "s = input()\nstack = []\npairs = {')': '(', ']': '[', '}': '{'}\nfor c in s:\n    if c in pairs.values():\n        stack.append(c)\n    elif c in pairs:\n        if not stack or stack.pop() != pairs[c]:\n            print('no')\n            exit()\nif stack:\n    print('no')\nelse:\n    print('yes')",
    "refactor_matrix:5549bd37": "n = int(input())\nmat = [list(map(int, input().split())) for _ in range(n)]\nprint(sum(map(lambda i: mat[i][i], range(n))))",
    "refactor_dict:207c878e": "s = input().replace(' ', '')\ncounts = {c: s.count(c) for c in set(s)}\nresult = [f\"{c} {counts[c]}\" for c in sorted(counts.keys())]\nprint('\\n'.join(result))",
    "refactor_dict:5c15066b": "s = input()\nwords = sorted(list(set(s.split())))\nresult = [' '.join([w, str(len(w))]) for w in words]\nprint('\\n'.join(result))",
    "refactor_graph:14b70985": "from collections import defaultdict, deque\n\nn, m = map(int, input().split())\nadj = defaultdict(list)\nfor _ in range(m):\n    u, v = map(int, input().split())\n    adj[u].append(v)\n    adj[v].append(u)\nstart, end = map(int, input().split())\n\nvisited = {start}\nqueue = deque([start])\n\nwhile queue:\n    node = queue.popleft()\n    if node == end:\n        print('yes')\n        exit()\n    for neighbor in adj[node]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            queue.append(neighbor)\n\nprint('no')",
    "refactor_graph:718f74c8": "def solve():\n    n, m = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    for i in range(n):\n        print(' '.join(map(str, sorted(adj[i]))))\n\nsolve()",
    "refactor_string_advanced:e7296fb5": "s = input()\nn = int(input())\nprint(''.join(chr((ord(c) - (base := ord('a') if c.islower() else ord('A')) + n) % 26 + base) if c.isalpha() else c for c in s))",
    "refactor_matrix:cf1a5d14": "r, c = map(int, input().split())\nrow_sums = [sum(map(int, input().split())) for _ in range(r)]\nfor row_sum in row_sums:\n    print(row_sum)",
    "refactor_list:9a24e4aa": "def solve():\n  n = int(input())\n  nums = list(map(int, [input() for _ in range(n)]))\n  unique_sorted = sorted(list(set(nums)))\n  print(unique_sorted[-2] if len(unique_sorted) >= 2 else max(nums))\n\nsolve()"
  },
  "promoted_s0": {
    "api_design:3b74a479": "from collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = OrderedDict()\n\n    def get(self, key):\n        if key not in self.cache:\n            return -1\n        else:\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            self.cache[key] = value\n            self.cache.move_to_end(key)\n        else:\n            if len(self.cache) == self.capacity:\n                self.cache.popitem(last=False)\n            self.cache[key] = value\n            self.cache.move_to_end(key)\n\nif __name__ == \"__main__\":\n    capacity = int(input())\n    n = int(input())\n    cache = LRUCache(capacity)\n    for _ in range(n):\n        line = input().split()\n        if line[0] == \"PUT\":\n            key = line[1]\n            value = int(line[2])\n            cache.put(key, value)\n        elif line[0] == \"GET\":\n            key = line[1]\n            print(cache.get(key))",
    "api_design:de6466ae": "class EventEmitter:\n    def __init__(self):\n        self.listeners = {}\n\n    def on(self, event, handler):\n        if event not in self.listeners:\n            self.listeners[event] = []\n        self.listeners[event].append(handler)\n\n    def off(self, event, handler):\n        if event in self.listeners:\n            self.listeners[event] = [h for h in self.listeners[event] if h != handler]\n\n    def emit(self, event):\n        if event in self.listeners and self.listeners[event]:\n            print(' '.join(self.listeners[event]))\n        else:\n            print('none')\n\nif __name__ == \"__main__\":\n    n = int(input())\n    emitter = EventEmitter()\n    for _ in range(n):\n        line = input().split()\n        operation = line[0]\n        if operation == 'ON':\n            event = line[1]\n            handler = line[2]\n            emitter.on(event, handler)\n        elif operation == 'OFF':\n            event = line[1]\n            handler = line[2]\n            emitter.off(event, handler)\n        elif operation == 'EMIT':\n            event = line[1]\n            emitter.emit(event)",
    "api_design:f3357733": "def rate_limiter():\n    W, M = map(int, input().split())\n    N = int(input())\n    timestamps = []\n    for _ in range(N):\n        timestamps.append(int(input()))\n\n    window = []\n    for t in timestamps:\n        while window and window[0] <= t - W:\n            window.pop(0)\n        \n        if len(window) < M:\n            print(\"allow\")\n            window.append(t)\n        else:\n            print(\"deny\")\n\nrate_limiter()",
    "simulation:966dcbfa": "def solve():\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n\n    new_grid = [['.' for _ in range(m)] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            live_neighbors = 0\n            for x in range(max(0, i - 1), min(n, i + 2)):\n                for y in range(max(0, j - 1), min(m, j + 2)):\n                    if (x, y) != (i, j) and grid[x][y] == '#':\n                        live_neighbors += 1\n\n            if grid[i][j] == '#':\n                if live_neighbors < 2 or live_neighbors > 3:\n                    new_grid[i][j] = '.'\n                else:\n                    new_grid[i][j] = '#'\n            else:\n                if live_neighbors == 3:\n                    new_grid[i][j] = '#'\n                else:\n                    new_grid[i][j] = '.'\n\n    for row in new_grid:\n        print(\"\".join(row))\n\nsolve()",
    "code_review:67d1b7d0": "n = int(input())\nopen_resources = set()\nclosed_resources = set()\n\nfor _ in range(n):\n    line = input().split()\n    operation = line[0]\n    resource = line[1]\n\n    if operation == 'OPEN':\n        open_resources.add(resource)\n    elif operation == 'CLOSE':\n        closed_resources.add(resource)\n\nleaked_resources = sorted(list(open_resources - closed_resources))\n\nif leaked_resources:\n    print(' '.join(leaked_resources))\nelse:\n    print('none')",
    "tree:f8986d19": "def solve():\n    n = int(input())\n    \n    if n == 1:\n        print(0)\n        return\n    \n    adj = [[] for _ in range(n)]\n    \n    for _ in range(n - 1):\n        parent, child = map(int, input().split())\n        adj[parent].append(child)\n    \n    def bfs(start_node):\n        q = [(start_node, 0)]\n        max_depth = 0\n        \n        while q:\n            node, depth = q.pop(0)\n            max_depth = max(max_depth, depth)\n            \n            for neighbor in adj[node]:\n                q.append((neighbor, depth + 1))\n        \n        return max_depth\n    \n    print(bfs(0))\n\nsolve()",
    "sliding_window:02200553": "def solve():\n    n, k = map(int, input().split())\n    nums = list(map(int, input().split()))\n    \n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for i in range(k):\n        current_sum += nums[i]\n    \n    max_sum = current_sum\n    \n    for i in range(k, n):\n        current_sum += nums[i] - nums[i - k]\n        max_sum = max(max_sum, current_sum)\n        \n    print(max_sum)\n\nsolve()",
    "heap:24d5bd9f": "import heapq\n\ndef merge_sorted_lists():\n    k = int(input())\n    heap = []\n    for _ in range(k):\n        line = list(map(int, input().split()))\n        n = line[0]\n        for i in range(1, n + 1):\n            heapq.heappush(heap, line[i])\n    \n    result = []\n    while heap:\n        result.append(heapq.heappop(heap))\n    \n    print(*result)\n\nmerge_sorted_lists()",
    "math_challenge:5d8c4732": "def modular_exponentiation(base, exponent, modulus):\n    result = 1\n    base = base % modulus\n    while exponent > 0:\n        if exponent % 2 == 1:\n            result = (result * base) % modulus\n        base = (base * base) % modulus\n        exponent //= 2\n    return result\n\nbase, exponent, modulus = map(int, input().split())\nprint(modular_exponentiation(base, exponent, modulus))",
    "math_challenge:8d94c320": "def sieve_of_eratosthenes(n):\n    prime = [True] * (n + 1)\n    p = 2\n    while (p * p <= n):\n        if (prime[p] == True):\n            for i in range(p * p, n + 1, p):\n                prime[i] = False\n        p += 1\n    primes = []\n    for p in range(2, n + 1):\n        if prime[p]:\n            primes.append(str(p))\n    return \" \".join(primes)\n\nn = int(input())\nprint(sieve_of_eratosthenes(n))",
    "heap:b7145f8b": "def solve():\n    nums = list(map(int, input().split()))\n    k = int(input())\n    nums.sort(reverse=True)\n    print(nums[k-1])\n\nsolve()",
    "parsing:f8c53b15": "def solve():\n    n = int(input())\n    data = {}\n    for _ in range(n):\n        line = input().split(',')\n        name = line[0]\n        category = line[1]\n        value = int(line[2])\n        if category in data:\n            data[category] += value\n        else:\n            data[category] = value\n    \n    sorted_categories = sorted(data.keys())\n    \n    for category in sorted_categories:\n        print(f\"{category}:{data[category]}\")\n\nsolve()",
    "greedy:535d0093": "amount = int(input())\ncoins = list(map(int, input().split()))\n\ncount = 0\nremaining = amount\n\nfor coin in coins:\n    while remaining >= coin:\n        remaining -= coin\n        count += 1\n\nif remaining == 0:\n    print(count)\nelse:\n    print(-1)",
    "parsing:c991d975": "def solve():\n    s = input()\n    stack = []\n    max_depth = 0\n    current_depth = 0\n    \n    mapping = {')': '(', ']': '[', '}': '{'}\n    \n    for char in s:\n        if char in ['(', '[', '{']:\n            stack.append(char)\n            current_depth += 1\n            max_depth = max(max_depth, current_depth)\n        elif char in [')', ']', '}']:\n            if not stack:\n                print(\"-1\")\n                return\n            \n            top = stack.pop()\n            if mapping[char] != top:\n                print(\"-1\")\n                return\n            current_depth -= 1\n            \n    if stack:\n        print(\"-1\")\n    else:\n        print(max_depth)\n\nsolve()",
    "greedy:c4be0065": "def solve():\n    nums = list(map(int, input().split()))\n    n = len(nums)\n    \n    reachable = 0\n    for i in range(n):\n        if i > reachable:\n            print(\"no\")\n            return\n        reachable = max(reachable, i + nums[i])\n        if reachable >= n - 1:\n            print(\"yes\")\n            return\n    \n    print(\"yes\")\n\nsolve()",
    "parsing:5a03fa62": "def evaluate_rpn():\n    n = int(input())\n    stack = []\n    for _ in range(n):\n        token = input()\n        if token.isdigit() or (token.startswith('-') and token[1:].isdigit()):\n            stack.append(int(token))\n        else:\n            operand2 = stack.pop()\n            operand1 = stack.pop()\n            if token == '+':\n                stack.append(operand1 + operand2)\n            elif token == '-':\n                stack.append(operand1 - operand2)\n            elif token == '*':\n                stack.append(operand1 * operand2)\n            elif token == '/':\n                if operand2 == 0:\n                    print(\"Error: Division by zero\")\n                    return\n                stack.append(int(operand1 / operand2))\n    print(stack[0])\n\nevaluate_rpn()",
    "tree:a262d416": "def solve():\n    n = int(input())\n    nodes = {}\n    for _ in range(n):\n        node_id, value, parent_id = input().split()\n        node_id = int(node_id)\n        value = int(value)\n        parent_id = int(parent_id)\n        nodes[node_id] = {\"value\": value, \"parent\": parent_id, \"children\": []}\n\n    for node_id, node in nodes.items():\n        parent_id = node[\"parent\"]\n        if parent_id != -1:\n            nodes[parent_id][\"children\"].append(node_id)\n\n    root_id = None\n    for node_id, node in nodes.items():\n        if node[\"parent\"] == -1:\n            root_id = node_id\n            break\n\n    levels = {}\n    def assign_levels(node_id, level):\n        if level not in levels:\n            levels[level] = []\n        levels[level].append(node_id)\n        for child_id in nodes[node_id][\"children\"]:\n            assign_levels(child_id, level + 1)\n\n    assign_levels(root_id, 0)\n\n    level_sums = {}\n    for level, node_ids in levels.items():\n        level_sum = 0\n        for node_id in node_ids:\n            level_sum += nodes[node_id][\"value\"]\n        level_sums[level] = level_sum\n\n    sorted_levels = sorted(level_sums.keys())\n    for level in sorted_levels:\n        print(level_sums[level])\n\nsolve()",
    "sliding_window:9fbf0a2c": "def solve():\n    s = input()\n    n = len(s)\n    max_len = 0\n    for i in range(n):\n        for j in range(i, n):\n            sub = s[i:j+1]\n            if len(set(sub)) == len(sub):\n                max_len = max(max_len, len(sub))\n    print(max_len)\n\nsolve()",
    "math_challenge:28a5beeb": "import math\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef lcm(a, b):\n    return (a * b) // gcd(a, b)\n\nnums = list(map(int, input().split()))\n\ngcd_val = nums[0]\nlcm_val = nums[0]\n\nfor i in range(1, len(nums)):\n    gcd_val = gcd(gcd_val, nums[i])\n    lcm_val = lcm(lcm_val, nums[i])\n\nprint(gcd_val, end=\" \")\n\ntemp_lcm = nums[0]\nfor i in range(1, len(nums)):\n  temp_lcm = lcm(temp_lcm, nums[i])\n\nprint(temp_lcm)",
    "greedy:865723ed": "def solve():\n    n = int(input())\n    activities = []\n    for _ in range(n):\n        start, end = map(int, input().split())\n        activities.append((start, end))\n    \n    activities.sort(key=lambda x: x[1])\n    \n    count = 0\n    last_end = -1\n    \n    for start, end in activities:\n        if start >= last_end:\n            count += 1\n            last_end = end\n            \n    print(count)\n\nsolve()",
    "simulation:08ccb6b5": "s = int(input())\nn = int(input())\nrejected = 0\nfor _ in range(n):\n    line = input().split()\n    op = line[0]\n    amount = int(line[1])\n    if op == 'D':\n        s += amount\n    elif op == 'W':\n        if amount <= s:\n            s -= amount\n        else:\n            rejected += 1\nprint(s, rejected)",
    "graph_advanced:c6cea67c": "def solve():\n    n, m = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n\n    def has_cycle():\n        visited = [0] * n  # 0: unvisited, 1: visiting, 2: visited\n        \n        def dfs(node):\n            visited[node] = 1\n            for neighbor in adj[node]:\n                if visited[neighbor] == 1:\n                    return True\n                if visited[neighbor] == 0:\n                    if dfs(neighbor):\n                        return True\n            visited[node] = 2\n            return False\n\n        for i in range(n):\n            if visited[i] == 0:\n                if dfs(i):\n                    return True\n        return False\n\n    if has_cycle():\n        print(\"yes\")\n    else:\n        print(\"no\")\n\nsolve()",
    "multi_step:648a245b": "def solve():\n    n = int(input())\n    state = \"IDLE\"\n\n    for _ in range(n):\n        cmd = input()\n\n        if state == \"IDLE\":\n            if cmd == \"START\":\n                state = \"RUNNING\"\n                print(state)\n            else:\n                print(f\"ERROR: invalid {cmd} in {state}\")\n        elif state == \"RUNNING\":\n            if cmd == \"PAUSE\":\n                state = \"PAUSED\"\n                print(state)\n            elif cmd == \"STOP\":\n                state = \"STOPPED\"\n                print(state)\n            else:\n                print(f\"ERROR: invalid {cmd} in {state}\")\n        elif state == \"PAUSED\":\n            if cmd == \"RESUME\":\n                state = \"RUNNING\"\n                print(state)\n            elif cmd == \"STOP\":\n                state = \"STOPPED\"\n                print(state)\n            else:\n                print(f\"ERROR: invalid {cmd} in {state}\")\n        elif state == \"STOPPED\":\n            if cmd == \"RESET\":\n                state = \"IDLE\"\n                print(state)\n            else:\n                print(f\"ERROR: invalid {cmd} in {state}\")\n\nsolve()",
    "graph_advanced:6f7fcf77": "def solve():\n    n, m = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * n\n    count = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            count += 1\n\n    print(count)\n\nsolve()",
    "code_review:c344cd6e": "def stable_sort():\n    n = int(input())\n    lines = []\n    for _ in range(n):\n        lines.append(input())\n\n    data = []\n    for line in lines:\n        name, value = line.split()\n        data.append((name, int(value)))\n\n    sorted_data = sorted(data, key=lambda x: x[1])\n\n    for name, value in sorted_data:\n        print(name, value)\n\nstable_sort()",
    "simulation:4dd4a940": "n = int(input())\nx = 0\ny = 0\nfor _ in range(n):\n    command = input()\n    if command == 'U':\n        y += 1\n    elif command == 'D':\n        y -= 1\n    elif command == 'L':\n        x -= 1\n    elif command == 'R':\n        x += 1\nprint(x, y)\nprint(abs(x) + abs(y))",
    "graph_advanced:e7298af4": "def solve():\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    colors = [-1] * n\n    \n    def is_bipartite(start_node):\n        if colors[start_node] == -1:\n            colors[start_node] = 0\n            queue = [start_node]\n            \n            while queue:\n                u = queue.pop(0)\n                \n                for v in adj[u]:\n                    if colors[v] == -1:\n                        colors[v] = 1 - colors[u]\n                        queue.append(v)\n                    elif colors[v] == colors[u]:\n                        return False\n        return True\n\n    for i in range(n):\n        if colors[i] == -1:\n            if not is_bipartite(i):\n                print(\"no\")\n                return\n\n    print(\"yes\")\n\nsolve()"
  },
  "candidates": {
    "bugfix:66322317": {
      "task_signature": "bugfix:66322317",
      "category": "bugfix",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 4,
      "consecutive_successes": 4,
      "failures": 0,
      "best_code": "a, b = map(int, input().split())\nwhile b != 0:\n    a, b = b, a % b\nprint(a)",
      "first_seen": 1770982017.0931385,
      "last_seen": 1771158587.8029132
    },
    "optimization:f3c5a6fc": {
      "task_signature": "optimization:f3c5a6fc",
      "category": "optimization",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 24,
      "consecutive_successes": 6,
      "failures": 12,
      "best_code": "def find_first_duplicate():\n    nums = []\n    first_line = input()\n    try:\n        n = int(first_line)\n    except ValueError:\n        print(\"none\")\n        return\n    \n    for _ in range(n):\n        try:\n            num = int(input())\n            nums.append(num)\n        except ValueError:\n            print(\"none\")\n            return\n        except EOFError:\n            print(\"none\")\n            return\n\n    seen = set()\n    for num in nums:\n        if num in seen:\n            print(num)\n            return\n        seen.add(num)\n\n    print(\"none\")\n\nfind_first_duplicate()",
      "first_seen": 1770982431.062356,
      "last_seen": 1771158588.031576
    },
    "multi_step:f03a1258": {
      "task_signature": "multi_step:f03a1258",
      "category": "multi_step",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 27,
      "consecutive_successes": 8,
      "failures": 7,
      "best_code": "def main():\n    n = int(input())\n    student_grades = []\n    for _ in range(n):\n        line = input().split()\n        name = line[0]\n        grade1 = int(line[1])\n        grade2 = int(line[2])\n        grade3 = int(line[3])\n        avg = (grade1 + grade2 + grade3) / 3\n        student_grades.append((name, avg))\n\n    student_averages = {}\n    for name, avg in student_grades:\n        if name in student_averages:\n            student_averages[name].append(avg)\n        else:\n            student_averages[name] = [avg]\n\n    final_averages = {}\n    for name, grade_list in student_averages.items():\n        final_averages[name] = sum(grade_list) / len(grade_list)\n    \n    sorted_students = sorted(final_averages.items(), key=lambda item: item[1], reverse=True)\n\n    output = []\n    for name, avg in sorted_students:\n        temp_list = [(n, a) for n, a in student_grades if n == name]\n        for n, a in temp_list:\n            output.append((n, a))\n\n    output.sort(key=lambda x: x[1], reverse=True)\n\n    seen = set()\n    for name, avg in output:\n        if (name, avg) not in seen:\n            print(f\"{name} {avg:.1f}\")\n            seen.add((name, avg))\n\n\nif __name__ == \"__main__\":\n    main()",
      "first_seen": 1770982957.3100939,
      "last_seen": 1771156792.1472552
    },
    "bugfix:1c3daedd": {
      "task_signature": "bugfix:1c3daedd",
      "category": "bugfix",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 4,
      "consecutive_successes": 4,
      "failures": 0,
      "best_code": "n = int(input())\nlst = [int(input()) for _ in range(n)]\n\nmax_so_far = lst[0]\ncurrent_max = lst[0]\n\nfor i in range(1, n):\n    current_max = max(lst[i], current_max + lst[i])\n    max_so_far = max(max_so_far, current_max)\n\nprint(max_so_far)",
      "first_seen": 1770982990.9442225,
      "last_seen": 1771071930.9037747
    },
    "bugfix:0452ab84": {
      "task_signature": "bugfix:0452ab84",
      "category": "bugfix",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 5,
      "consecutive_successes": 5,
      "failures": 0,
      "best_code": "n = int(input())\nif n == 0:\n    print(0)\nelif n == 1:\n    print(1)\nelse:\n    a, b = 0, 1\n    for _ in range(n - 1):\n        a, b = b, a + b\n    print(b)",
      "first_seen": 1770984860.5837202,
      "last_seen": 1771141678.0868042
    },
    "arithmetic:355fe65f": {
      "task_signature": "arithmetic:355fe65f",
      "category": "arithmetic",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "a = int(input())\nb = int(input())\nprint(a - b)",
      "first_seen": 1770984874.0291495,
      "last_seen": 1771071159.3817365
    },
    "refactor_data_structure:505ed8ea": {
      "task_signature": "refactor_data_structure:505ed8ea",
      "category": "refactor_data_structure",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    stack = []\n    \n    def process_line(line):\n        nonlocal stack\n        parts = line.split()\n        op = parts[0]\n        \n        if op == 'push':\n            stack.append(int(parts[1]))\n        elif op == 'pop':\n            if stack:\n                stack.pop()\n        elif op == 'min':\n            if stack:\n                print(min(stack))\n\n    list(map(lambda _: process_line(input()), range(n)))\n\nsolve()",
      "first_seen": 1770987177.4236536,
      "last_seen": 1771005055.4087315
    },
    "refactor_graph:61758022": {
      "task_signature": "refactor_graph:61758022",
      "category": "refactor_graph",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "def solve():\n    n, m = map(int, input().split())\n    parent = list(range(n))\n    rank = [0] * n\n\n    def find(i):\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent[i])\n        return parent[i]\n\n    def union(i, j):\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            if rank[root_i] < rank[root_j]:\n                parent[root_i] = root_j\n            elif rank[root_i] > rank[root_j]:\n                parent[root_j] = root_i\n            else:\n                parent[root_j] = root_i\n                rank[root_i] += 1\n            return True\n        return False\n\n    for _ in range(m):\n        u, v = map(int, input().split())\n        union(u, v)\n\n    components = 0\n    for i in range(n):\n        if parent[i] == i:\n            components += 1\n    \n    roots = set()\n    for i in range(n):\n        roots.add(find(i))\n\n    print(len(roots))\n\nsolve()",
      "first_seen": 1770989390.1564531,
      "last_seen": 1771138700.4758782
    },
    "chain_reasoning:9d061625": {
      "task_signature": "chain_reasoning:9d061625",
      "category": "chain_reasoning",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    logs = []\n    for _ in range(n):\n        logs.append(input())\n\n    anomalies = 0\n    max_latency = 0\n    max_latency_index = -1\n    error_messages = []\n    critical_count = 0\n\n    for i, log in enumerate(logs):\n        parts = log.split()\n        level = parts[1]\n        message = \" \".join(parts[2:-1])\n        latency = int(parts[-1].split('=')[1][:-2])\n\n        if level in (\"ERROR\", \"CRITICAL\") or latency > 1000:\n            anomalies += 1\n\n        if latency > max_latency:\n            max_latency = latency\n            max_latency_index = i\n\n        if level in (\"ERROR\", \"CRITICAL\"):\n            error_messages.append(message)\n\n        if level == \"CRITICAL\":\n            critical_count += 1\n\n    from collections import Counter\n    if error_messages:\n        most_common_error = Counter(error_messages).most_common(1)[0][0]\n    else:\n        most_common_error = \"\"\n\n    print(anomalies)\n    print(max_latency_index, max_latency)\n    print(most_common_error)\n    print(critical_count)\n\nsolve()",
      "first_seen": 1770991194.6877294,
      "last_seen": 1770991194.687732
    },
    "security_audit:c94f70fd": {
      "task_signature": "security_audit:c94f70fd",
      "category": "security_audit",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 0,
      "failures": 2,
      "best_code": "def main():\n    n = int(input())\n    vulnerabilities = {\n        \"lodash@4.17.15\": (\"CVE-2020-8203\", \"HIGH\"),\n        \"express@4.17.1\": (\"CVE-2022-24999\", \"MEDIUM\"),\n        \"axios@0.21.0\": (\"CVE-2021-3749\", \"HIGH\"),\n        \"jsonwebtoken@8.5.0\": (\"CVE-2022-23529\", \"CRITICAL\"),\n        \"minimist@1.2.5\": (\"CVE-2021-44906\", \"CRITICAL\"),\n        \"moment@2.29.1\": (\"CVE-2022-31129\", \"HIGH\"),\n        \"node-fetch@2.6.1\": (\"CVE-2022-0235\", \"HIGH\"),\n    }\n    \n    vulnerable_packages = []\n    for _ in range(n):\n        package_version = input()\n        if package_version in vulnerabilities:\n            vulnerable_packages.append((package_version, vulnerabilities[package_version][0], vulnerabilities[package_version][1]))\n    \n    print(len(vulnerable_packages))\n    \n    severity_order = {\"CRITICAL\": 0, \"HIGH\": 1, \"MEDIUM\": 2, \"LOW\": 3}\n    vulnerable_packages.sort(key=lambda x: severity_order[x[2]])\n    \n    for package, cve, severity in vulnerable_packages:\n        print(f\"{package} {cve} {severity}\")\n    \n    if any(severity == \"CRITICAL\" for _, _, severity in vulnerable_packages):\n        print(\"BLOCK\")\n    elif any(severity in [\"HIGH\", \"MEDIUM\"] for _, _, severity in vulnerable_packages):\n        print(\"WARN\")\n    else:\n        print(\"PASS\")\n\nif __name__ == \"__main__\":\n    main()",
      "first_seen": 1770991410.3404877,
      "last_seen": 1770991410.3404896
    },
    "chain_reasoning:9699bc4d": {
      "task_signature": "chain_reasoning:9699bc4d",
      "category": "chain_reasoning",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    logs = []\n    for _ in range(n):\n        logs.append(input())\n\n    anomalies = 0\n    max_latency = 0\n    max_latency_index = -1\n    error_messages = []\n    critical_count = 0\n\n    for i, log in enumerate(logs):\n        parts = log.split()\n        level = parts[1]\n        message = \" \".join(parts[2:-1])\n        latency = int(parts[-1].split('=')[1][:-2])\n\n        if level in (\"ERROR\", \"CRITICAL\") or latency > 1000:\n            anomalies += 1\n\n        if latency > max_latency:\n            max_latency = latency\n            max_latency_index = i\n\n        if level in (\"ERROR\", \"CRITICAL\"):\n            error_messages.append(message)\n\n        if level == \"CRITICAL\":\n            critical_count += 1\n\n    from collections import Counter\n    if error_messages:\n        most_common_error = Counter(error_messages).most_common(1)[0][0]\n    else:\n        most_common_error = \"\"\n\n    print(anomalies)\n    print(max_latency_index, max_latency)\n    print(most_common_error)\n    print(critical_count)\n\nsolve()",
      "first_seen": 1770991491.5054264,
      "last_seen": 1770991491.505429
    },
    "massive_scale:044fede1": {
      "task_signature": "massive_scale:044fede1",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n, k = map(int, input().split())\n    a = []\n    for _ in range(n):\n        a.append(int(input()))\n\n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for i in range(k):\n        current_sum += a[i]\n    \n    max_sum = current_sum\n    \n    for i in range(k, n):\n        current_sum += a[i]\n        current_sum -= a[i - k]\n        max_sum = max(max_sum, current_sum)\n        \n    print(max_sum)\n\nsolve()",
      "first_seen": 1770991612.0336676,
      "last_seen": 1770991612.03367
    },
    "devops_debug:11d2c358": {
      "task_signature": "devops_debug:11d2c358",
      "category": "devops_debug",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    rules = []\n    for _ in range(n):\n        rules.append(input().split())\n\n    port_actions = {}\n    for action, proto, port, source in rules:\n        port = int(port)\n        if port not in port_actions:\n            port_actions[port] = {'ALLOW': 0, 'DENY': 0}\n        port_actions[port][action] += 1\n\n    conflict_ports = []\n    for port, counts in port_actions.items():\n        if counts['ALLOW'] > 0 and counts['DENY'] > 0:\n            conflict_ports.append(port)\n\n    conflict_ports.sort()\n    num_conflicts = len(conflict_ports)\n    print(num_conflicts)\n    if num_conflicts > 0:\n        print(*conflict_ports)\n    else:\n        print(\"none\")\n\n    dangerous_ports = [22, 3306, 5432, 6379, 27017]\n    dangerous_rules_count = 0\n    dangerous_ports_found = []\n\n    for action, proto, port, source in rules:\n        port = int(port)\n        if action == 'ALLOW' and source == '0.0.0.0/0' and port in dangerous_ports:\n            dangerous_rules_count += 1\n            if port not in dangerous_ports_found:\n                dangerous_ports_found.append(port)\n\n    dangerous_ports_found.sort()\n    print(dangerous_rules_count)\n    if len(dangerous_ports_found) > 0:\n        print(*dangerous_ports_found)\n    else:\n        print(\"none\")\n\nsolve()",
      "first_seen": 1770991624.7857008,
      "last_seen": 1770991624.785703
    },
    "massive_scale:b5bc312d": {
      "task_signature": "massive_scale:b5bc312d",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n, k = map(int, input().split())\n    nums = []\n    for _ in range(n):\n        nums.append(int(input()))\n\n    max_sum = float('-inf')\n    current_sum = sum(nums[:k])\n    max_sum = current_sum\n\n    for i in range(k, n):\n        current_sum += nums[i] - nums[i - k]\n        max_sum = max(max_sum, current_sum)\n\n    print(max_sum)\n\nsolve()",
      "first_seen": 1770991671.0977795,
      "last_seen": 1770991671.0977817
    },
    "massive_scale:ef68b67a": {
      "task_signature": "massive_scale:ef68b67a",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    \n    total_lines = 0\n    total_functions = 0\n    total_classes = 0\n    total_complexity = 0\n    \n    max_complexity = 0\n    max_complexity_file = \"\"\n    \n    max_lines = 0\n    max_lines_file = \"\"\n    \n    complexity_gt_10 = 0\n    imports_gt_10 = 0\n    \n    files_data = []\n    \n    for _ in range(n):\n        line = input()\n        parts = line.split()\n        \n        filename = parts[0]\n        lines = int(parts[1])\n        functions = int(parts[2])\n        classes = int(parts[3])\n        imports = int(parts[4])\n        complexity = int(parts[5])\n        \n        files_data.append((filename, lines, functions, classes, imports, complexity))\n        \n        total_lines += lines\n        total_functions += functions\n        total_classes += classes\n        total_complexity += complexity\n        \n        if complexity > max_complexity:\n            max_complexity = complexity\n            max_complexity_file = filename\n            \n        if lines > max_lines:\n            max_lines = lines\n            max_lines_file = filename\n            \n        if complexity > 10:\n            complexity_gt_10 += 1\n            \n        if imports > 10:\n            imports_gt_10 += 1\n            \n    avg_complexity = total_complexity / n\n    \n    print(f\"{total_lines} {total_functions} {total_classes}\")\n    print(f\"{avg_complexity:.1f}\")\n    print(f\"{max_complexity_file} {max_complexity}\")\n    print(f\"{max_lines_file} {max_lines}\")\n    print(complexity_gt_10)\n    print(imports_gt_10)\n\nsolve()",
      "first_seen": 1770991878.0972443,
      "last_seen": 1770999189.4761133
    },
    "refactor_list:e488c6c0": {
      "task_signature": "refactor_list:e488c6c0",
      "category": "refactor_list",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "n = int(input())\nprint(sum(map(int, [input() for _ in range(n)])))",
      "first_seen": 1770992845.6651623,
      "last_seen": 1771005049.8500013
    },
    "chain_reasoning:38426c31": {
      "task_signature": "chain_reasoning:38426c31",
      "category": "chain_reasoning",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    data = []\n    for _ in range(n):\n        line = input()\n        data.append(line.split(','))\n\n    valid_records = []\n    invalid_count = 0\n    for record in data:\n        try:\n            name = record[0]\n            age = int(record[1])\n            salary = int(record[2])\n            department = record[3]\n            if age >= 0 and salary >= 0:\n                valid_records.append((name, age, salary, department))\n            else:\n                invalid_count += 1\n        except ValueError:\n            invalid_count += 1\n\n    valid_count = len(valid_records)\n\n    department_salaries = {}\n    for record in valid_records:\n        department = record[3]\n        salary = record[2]\n        if department in department_salaries:\n            department_salaries[department].append(salary)\n        else:\n            department_salaries[department] = [salary]\n\n    department_avg_salaries = {}\n    for department, salaries in department_salaries.items():\n        department_avg_salaries[department] = sum(salaries) // len(salaries)\n\n    sorted_departments = sorted(department_avg_salaries.items(), key=lambda item: item[1], reverse=True)\n\n    print(valid_count)\n    print(invalid_count)\n    for department, avg_salary in sorted_departments:\n        print(f\"{department} {avg_salary}\")\n\nsolve()",
      "first_seen": 1770993027.2587256,
      "last_seen": 1770993027.2587287
    },
    "chain_reasoning:c208ef75": {
      "task_signature": "chain_reasoning:c208ef75",
      "category": "chain_reasoning",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    data = []\n    for _ in range(n):\n        data.append(input())\n\n    valid_records = []\n    invalid_count = 0\n    for record in data:\n        name, age, salary, department = record.split(',')\n        age = int(age)\n        salary = int(salary)\n        if age >= 0 and salary >= 0:\n            valid_records.append((name, age, salary, department))\n        else:\n            invalid_count += 1\n\n    valid_count = len(valid_records)\n\n    department_salaries = {}\n    for name, age, salary, department in valid_records:\n        if department not in department_salaries:\n            department_salaries[department] = []\n        department_salaries[department].append(salary)\n\n    department_avg_salaries = {}\n    for department, salaries in department_salaries.items():\n        department_avg_salaries[department] = sum(salaries) // len(salaries)\n\n    sorted_departments = sorted(department_avg_salaries.items(), key=lambda item: item[1], reverse=True)\n\n    print(valid_count)\n    print(invalid_count)\n    for department, avg_salary in sorted_departments:\n        print(f\"{department} {avg_salary}\")\n\nsolve()",
      "first_seen": 1770993139.0443063,
      "last_seen": 1770996088.513578
    },
    "adversarial:ec0207bd": {
      "task_signature": "adversarial:ec0207bd",
      "category": "adversarial",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 0,
      "failures": 5,
      "best_code": "def solve():\n    n = int(input())\n    for _ in range(n):\n        s = input()\n        length = len(s)\n        words = len(s.split())\n        upper = s.upper()\n        print(length, words, upper)\n\nsolve()",
      "first_seen": 1770993147.1069965,
      "last_seen": 1770993147.106998
    },
    "devops_debug:dc036617": {
      "task_signature": "devops_debug:dc036617",
      "category": "devops_debug",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    stages = []\n    for _ in range(n):\n        stages.append(input())\n\n    problems = []\n    deploy_stage = None\n    test_stage_exists = False\n\n    stage_names = []\n    stage_dependencies = {}\n    stage_timeouts = {}\n    stage_retries = {}\n\n    for stage_str in stages:\n        parts = stage_str.split()\n        stage_name = parts[0]\n        stage_names.append(stage_name)\n\n        dependencies_str = parts[1]\n        _, dependency_value = dependencies_str.split(\"=\")\n        stage_dependencies[stage_name] = dependency_value\n\n        timeout_str = parts[2]\n        _, timeout_value = timeout_str.split(\"=\")\n        stage_timeouts[stage_name] = int(timeout_value)\n\n        retry_str = parts[3]\n        _, retry_value = retry_str.split(\"=\")\n        stage_retries[stage_name] = int(retry_value)\n    \n    for stage_name in stage_names:\n        if stage_timeouts[stage_name] == 0:\n            problems.append(f\"NO_TIMEOUT:{stage_name}\")\n        \n        if stage_name == \"deploy\" and stage_retries[stage_name] > 0:\n            problems.append(f\"DEPLOY_RETRY:{stage_name}\")\n            deploy_stage = stage_name\n        \n        if stage_name == \"test\":\n            test_stage_exists = True\n    \n    if deploy_stage is not None:\n        deploy_index = stage_names.index(\"deploy\")\n        test_before_deploy = False\n        for i in range(deploy_index):\n            if stage_names[i] == \"test\":\n                test_before_deploy = True\n                break\n        \n        if not test_before_deploy and not test_stage_exists:\n            \n            found_deploy = False\n            for stage_name in stage_names:\n                if stage_name == \"deploy\":\n                    found_deploy = True\n            \n            if found_deploy:\n                problems.append(\"DEPLOY_WITHOUT_TEST\")\n    \n    print(len(problems))\n    if len(problems) == 0:\n        print(\"NONE\")\n    else:\n        for problem in problems:\n            print(problem)\n\nsolve()",
      "first_seen": 1770993287.86186,
      "last_seen": 1770993287.8618627
    },
    "devops_debug:00999a38": {
      "task_signature": "devops_debug:00999a38",
      "category": "devops_debug",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "def ip_to_int(ip_address):\n    octets = map(int, ip_address.split('.'))\n    return sum(octet << (8 * (3 - i)) for i, octet in enumerate(octets))\n\ndef subnet_mask(cidr):\n    return (0xFFFFFFFF << (32 - cidr)) & 0xFFFFFFFF\n\ndef network_address(ip_int, mask):\n    return ip_int & mask\n\ndef int_to_ip(ip_int):\n    return '.'.join(str((ip_int >> (8 * (3 - i))) & 0xFF) for i in range(4))\n\nnum_rules = int(input())\nrules = []\nfor _ in range(num_rules):\n    rules.append(input().split())\n\nport_actions = {}\nfor rule in rules:\n    action, protocol, port, source = rule\n    port = int(port)\n    if port not in port_actions:\n        port_actions[port] = {'ALLOW': [], 'DENY': []}\n    port_actions[port][action].append(source)\n\nconflicting_ports = []\nfor port, actions in port_actions.items():\n    if actions['ALLOW'] and actions['DENY']:\n        conflicting_ports.append(port)\n\nconflicting_ports.sort()\n\ndangerous_rules_count = 0\ndangerous_ports = []\nsensitive_ports = [22, 3306, 5432, 6379, 27017]\n\nfor rule in rules:\n    action, protocol, port, source = rule\n    port = int(port)\n    if action == 'ALLOW' and source == '0.0.0.0/0' and port in sensitive_ports:\n        dangerous_rules_count += 1\n        dangerous_ports.append(port)\n\ndangerous_ports = sorted(list(set(dangerous_ports)))\n\nprint(len(conflicting_ports))\nif conflicting_ports:\n    print(*conflicting_ports)\nelse:\n    print('none')\n\nprint(dangerous_rules_count)\nif dangerous_ports:\n    print(*dangerous_ports)\nelse:\n    print('none')",
      "first_seen": 1770993456.1996899,
      "last_seen": 1770994629.0570843
    },
    "real_world_auto:0943fc85": {
      "task_signature": "real_world_auto:0943fc85",
      "category": "real_world_auto",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    num_requests = int(input())\n    \n    request_data = []\n    for _ in range(num_requests):\n        request_data.append(input().split())\n\n    successful_requests = 0\n    total_attempts = 0\n    output_lines = []\n\n    for request in request_data:\n        url = request[0]\n        statuses = [int(s) for s in request[1:]]\n        \n        attempts = 0\n        total_backoff = 0\n        \n        for i, status in enumerate(statuses):\n            attempts += 1\n            \n            if status == 200:\n                successful_requests += 1\n                output_lines.append(f\"{url} 200 {attempts} {total_backoff}s\")\n                break\n            elif status in [429, 500, 503]:\n                backoff = 2**i\n                total_backoff += backoff\n            else:\n                output_lines.append(f\"{url} {status} {attempts} {total_backoff - (2**(i-1) if i > 0 else 0)}s\")\n                break\n        else:\n            output_lines.append(f\"{url} {statuses[-1]} {attempts} {total_backoff}s\")\n\n        total_attempts += attempts\n\n    print(f\"{successful_requests}/{num_requests}\")\n    print(total_attempts)\n    for line in output_lines:\n        print(line)\n\nsolve()",
      "first_seen": 1770993922.0839958,
      "last_seen": 1770993922.0839996
    },
    "security_audit:765f5eca": {
      "task_signature": "security_audit:765f5eca",
      "category": "security_audit",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "import hashlib\nimport subprocess\nimport os\nimport re\n\nn = int(input())\nvulns = []\n\nfor _ in range(n):\n    line = input()\n    if \"hashlib.md5\" in line:\n        vulns.append(\"WEAK_CRYPTO bcrypt\")\n    elif \"subprocess.run\" in line and \"[\" not in line:\n        vulns.append(\"COMMAND_INJECTION subprocess_list\")\n    elif \"os.system\" in line:\n        vulns.append(\"COMMAND_INJECTION subprocess_list\")\n    elif \"cursor.execute\" in line and \"f\\\"\" in line:\n        vulns.append(\"SQL_INJECTION parameterized\")\n    elif \"cursor.execute\" in line and \"+\" in line:\n        vulns.append(\"SQL_INJECTION parameterized\")\n    elif \"cursor.execute\" in line and \"%s\" in line:\n        vulns.append(\"SQL_INJECTION parameterized\")\n    elif \"html = f\" in line:\n        vulns.append(\"XSS escape\")\n    else:\n        vulns.append(\"SAFE none\")\n\nfor vuln in vulns:\n    print(vuln)\n\nprint(len([v for v in vulns if v != \"SAFE none\"]))",
      "first_seen": 1770993934.5029566,
      "last_seen": 1770996244.2522702
    },
    "real_world_auto:73d51bd2": {
      "task_signature": "real_world_auto:73d51bd2",
      "category": "real_world_auto",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 4,
      "consecutive_successes": 4,
      "failures": 0,
      "best_code": "def solve():\n    n1 = int(input())\n    base_config = {}\n    for _ in range(n1):\n        line = input().strip()\n        key, value = line.split(\"=\", 1)\n        try:\n            # Attempt to convert to int, float, or bool\n            if value.lower() == \"true\":\n                value = True\n            elif value.lower() == \"false\":\n                value = False\n            elif '.' in value:\n                value = float(value)\n            else:\n                value = int(value)\n        except ValueError:\n            # If conversion fails, keep it as a string\n            pass\n        base_config[key] = value\n\n    n2 = int(input())\n    overrides = {}\n    for _ in range(n2):\n        line = input().strip()\n        key, value = line.split(\"=\", 1)\n        try:\n            # Attempt to convert to int, float, or bool\n            if value.lower() == \"true\":\n                value = True\n            elif value.lower() == \"false\":\n                value = False\n            elif '.' in value:\n                value = float(value)\n            else:\n                value = int(value)\n        except ValueError:\n            # If conversion fails, keep it as a string\n            pass\n        overrides[key] = value\n\n    merged_config = base_config.copy()\n    overwritten_count = 0\n    for key, value in overrides.items():\n        if key in merged_config:\n            overwritten_count += 1\n        merged_config[key] = value\n\n    print(len(merged_config))\n    for key in sorted(merged_config.keys()):\n        print(f\"{key}={merged_config[key]}\")\n    print(overwritten_count)\n\nsolve()",
      "first_seen": 1770993976.7769194,
      "last_seen": 1770999868.6239245
    },
    "massive_scale:1ae87390": {
      "task_signature": "massive_scale:1ae87390",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n, k = map(int, input().split())\n    nums = []\n    for _ in range(n):\n        nums.append(int(input()))\n\n    max_sum = float('-inf')\n    current_sum = 0\n\n    for i in range(k):\n        current_sum += nums[i]\n\n    max_sum = current_sum\n\n    for i in range(k, n):\n        current_sum += nums[i]\n        current_sum -= nums[i - k]\n        max_sum = max(max_sum, current_sum)\n\n    print(max_sum)\n\nsolve()",
      "first_seen": 1770994025.535432,
      "last_seen": 1770994025.5354354
    },
    "massive_scale:92967e9e": {
      "task_signature": "massive_scale:92967e9e",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n_files = int(input())\n    \n    files_data = []\n    for _ in range(n_files):\n        line = input().split()\n        filename = line[0]\n        rows = int(line[1])\n        functions = int(line[2])\n        classes = int(line[3])\n        imports = int(line[4])\n        complexity = int(line[5])\n        files_data.append((filename, rows, functions, classes, imports, complexity))\n    \n    total_rows = sum(file[1] for file in files_data)\n    total_functions = sum(file[2] for file in files_data)\n    total_classes = sum(file[3] for file in files_data)\n    \n    print(f\"{total_rows} {total_functions} {total_classes}\")\n    \n    avg_complexity = sum(file[5] for file in files_data) / n_files\n    print(f\"{avg_complexity:.1f}\")\n    \n    most_complex_file = max(files_data, key=lambda x: x[5])\n    print(f\"{most_complex_file[0]} {most_complex_file[5]}\")\n    \n    largest_file = max(files_data, key=lambda x: x[1])\n    print(f\"{largest_file[0]} {largest_file[1]}\")\n    \n    complex_files_count = sum(1 for file in files_data if file[5] > 10)\n    print(complex_files_count)\n    \n    import_files_count = sum(1 for file in files_data if file[4] > 10)\n    print(import_files_count)\n\nsolve()",
      "first_seen": 1770994040.2854102,
      "last_seen": 1770994040.285412
    },
    "massive_scale:18d41c5e": {
      "task_signature": "massive_scale:18d41c5e",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n_files = int(input())\n    \n    rows = []\n    functions = []\n    classes = []\n    complexities = []\n    imports = []\n    filenames = []\n    \n    for _ in range(n_files):\n        line = input().split()\n        filename = line[0]\n        row = int(line[1])\n        function = int(line[2])\n        class_ = int(line[3])\n        import_ = int(line[4])\n        complexity = int(line[5])\n        \n        filenames.append(filename)\n        rows.append(row)\n        functions.append(function)\n        classes.append(class_)\n        imports.append(import_)\n        complexities.append(complexity)\n    \n    total_rows = sum(rows)\n    total_functions = sum(functions)\n    total_classes = sum(classes)\n    \n    avg_complexity = sum(complexities) / len(complexities)\n    \n    max_complexity = max(complexities)\n    max_complexity_index = complexities.index(max_complexity)\n    max_complexity_filename = filenames[max_complexity_index]\n    \n    max_rows = max(rows)\n    max_rows_index = rows.index(max_rows)\n    max_rows_filename = filenames[max_rows_index]\n    \n    complex_files = len([c for c in complexities if c > 10])\n    import_files = len([i for i in imports if i > 10])\n    \n    print(f\"{total_rows} {total_functions} {total_classes}\")\n    print(f\"{avg_complexity:.1f}\")\n    print(f\"{max_complexity_filename} {max_complexity}\")\n    print(f\"{max_rows_filename} {max_rows}\")\n    print(complex_files)\n    print(import_files)\n\nsolve()",
      "first_seen": 1770994073.6993957,
      "last_seen": 1770994073.699397
    },
    "massive_scale:f811d5c7": {
      "task_signature": "massive_scale:f811d5c7",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n, k = map(int, input().split())\n    nums = []\n    for _ in range(n):\n        nums.append(int(input()))\n\n    max_sum = float('-inf')\n    current_sum = sum(nums[:k])\n    max_sum = current_sum\n\n    for i in range(k, n):\n        current_sum += nums[i] - nums[i - k]\n        max_sum = max(max_sum, current_sum)\n\n    print(max_sum)\n\nsolve()",
      "first_seen": 1770994524.987164,
      "last_seen": 1770994524.987167
    },
    "cross_domain:1a044822": {
      "task_signature": "cross_domain:1a044822",
      "category": "cross_domain",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 5,
      "consecutive_successes": 5,
      "failures": 0,
      "best_code": "import hashlib\n\n# STEG 1 — PARSA INPUT:\nip_cidr = input()\nip, cidr = ip_cidr.split('/')\ncidr = int(cidr)\noctets = [int(p) for p in ip.split('.')]\n\n# STEG 2 — BERAKNA SUBNET_MASK:\nsubnet_mask = (0xFFFFFFFF << (32 - cidr)) & 0xFFFFFFFF\n\n# STEG 3 — BERAKNA IP_TO_INT:\nip_to_int = sum(octet << (8*(3-i)) for i, octet in enumerate(octets))\n\n# STEG 4 — BERAKNA NETWORK_ADDR:\nnetwork_addr = ip_to_int & subnet_mask\n\n# STEG 5 — BERAKNA INT_TO_IP:\nint_to_ip = '.'.join(str((network_addr >> (8*(3-i))) & 0xFF) for i in range(4))\n\n# STEG 6 — BERAKNA BROADCAST_ADDR:\nbroadcast_addr = network_addr | (~subnet_mask & 0xFFFFFFFF)\nbroadcast_ip = '.'.join(str((broadcast_addr >> (8*(3-i))) & 0xFF) for i in range(4))\n\n# STEG 7 — BERAKNA NUM_HOSTS:\nnum_hosts = max(2**(32 - cidr) - 2, 0)\n\n# STEG 8 — BERAKNA SHA256_HEX:\nnetwork_addr_str = '.'.join(str((network_addr >> (8*(3-i))) & 0xFF) for i in range(4))\nsha256_hex = hashlib.sha256(network_addr_str.encode()).hexdigest()\nsha256_hex = sha256_hex[:16]\n\n# STEG 9 — BERAKNA CHECKSUM_MOD:\nchecksum_mod = sum(octets) % 256\n\n# STEG 10 — OUTPUT:\nprint(int_to_ip)\nprint(broadcast_ip)\nprint(num_hosts)\nprint(sha256_hex)\nprint(checksum_mod)",
      "first_seen": 1770994604.6903672,
      "last_seen": 1771000030.6219213
    },
    "chain_reasoning:5620bd26": {
      "task_signature": "chain_reasoning:5620bd26",
      "category": "chain_reasoning",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    data = []\n    for _ in range(n):\n        data.append(input())\n\n    valid_records = []\n    invalid_count = 0\n    for record in data:\n        name, age, salary, department = record.split(',')\n        age = int(age)\n        salary = int(salary)\n        if age >= 0 and salary >= 0:\n            valid_records.append((name, age, salary, department))\n        else:\n            invalid_count += 1\n\n    department_salaries = {}\n    for name, age, salary, department in valid_records:\n        if department not in department_salaries:\n            department_salaries[department] = []\n        department_salaries[department].append(salary)\n\n    department_avg_salaries = {}\n    for department, salaries in department_salaries.items():\n        department_avg_salaries[department] = sum(salaries) // len(salaries)\n\n    sorted_departments = sorted(department_avg_salaries.items(), key=lambda item: item[1], reverse=True)\n\n    print(len(valid_records))\n    print(invalid_count)\n    for department, avg_salary in sorted_departments:\n        print(f\"{department} {avg_salary}\")\n\nsolve()",
      "first_seen": 1770994618.9280932,
      "last_seen": 1770994618.9280956
    },
    "security_audit:59baa2b3": {
      "task_signature": "security_audit:59baa2b3",
      "category": "security_audit",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    lines = []\n    for _ in range(n):\n        lines.append(input())\n\n    vulnerabilities = 0\n    \n    if n > 0:\n        if \"cursor.execute(\\\"SELECT * FROM orders WHERE id = \\\" + order_id)\" in lines:\n            print(\"SQL_INJECTION parameterized\")\n            vulnerabilities += 1\n        else:\n            print(\"SAFE none\")\n    if n > 1:\n        if \"os.system(f\\\"ping {hostname}\\\")\" in lines:\n            print(\"COMMAND_INJECTION subprocess_list\")\n            vulnerabilities += 1\n        else:\n            print(\"SAFE none\")\n    if n > 2:\n        if \"html = f\\\"<div>{user_comment}</div>\\\"\" in lines:\n            print(\"XSS escape\")\n            vulnerabilities += 1\n        else:\n            print(\"SAFE none\")\n    if n > 3:\n        if \"query = f\\\"SELECT * FROM users WHERE name = '{user_input}'\\\"\" in lines:\n            print(\"SQL_INJECTION parameterized\")\n            vulnerabilities += 1\n        else:\n            print(\"SAFE none\")\n    if n > 4:\n        if \"token = str(random.randint(100000, 999999))\" in lines:\n            print(\"WEAK_RANDOM secrets\")\n            vulnerabilities += 1\n        else:\n            print(\"SAFE none\")\n    if n > 5:\n        if \"subprocess.run([\\\"ping\\\", hostname])\" in lines:\n            print(\"SAFE none\")\n        else:\n            print(\"SAFE none\")\n    if n > 6:\n        if \"cursor.execute(\\\"SELECT * FROM products WHERE id = ?\\\", (product_id,))\" in lines:\n            print(\"SAFE none\")\n        else:\n            print(\"SAFE none\")\n\n    print(vulnerabilities)\n\nsolve()",
      "first_seen": 1770994748.3094587,
      "last_seen": 1770997457.760749
    },
    "chain_reasoning:25455f57": {
      "task_signature": "chain_reasoning:25455f57",
      "category": "chain_reasoning",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    data = []\n    for _ in range(n):\n        data.append(input())\n\n    valid_records = []\n    invalid_count = 0\n\n    for record in data:\n        name, age, salary, department = record.split(',')\n        age = int(age)\n        salary = int(salary)\n\n        if age >= 0 and salary >= 0:\n            valid_records.append((name, age, salary, department))\n        else:\n            invalid_count += 1\n\n    valid_count = len(valid_records)\n\n    department_salaries = {}\n    for name, age, salary, department in valid_records:\n        if department not in department_salaries:\n            department_salaries[department] = []\n        department_salaries[department].append(salary)\n\n    department_avg_salaries = {}\n    for department, salaries in department_salaries.items():\n        department_avg_salaries[department] = sum(salaries) // len(salaries)\n\n    sorted_departments = sorted(department_avg_salaries.items(), key=lambda item: item[1], reverse=True)\n\n    print(valid_count)\n    print(invalid_count)\n    for department, avg_salary in sorted_departments:\n        print(department, avg_salary)\n\nsolve()",
      "first_seen": 1770994838.443957,
      "last_seen": 1770994838.4439597
    },
    "adversarial:9349fc92": {
      "task_signature": "adversarial:9349fc92",
      "category": "adversarial",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 5,
      "consecutive_successes": 5,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    discount = float(input())\n    prices = []\n    for _ in range(n):\n        prices.append(float(input()))\n\n    discounted_prices = []\n    for price in prices:\n        discounted_price = round(price * (1 - discount), 2)\n        discounted_prices.append(discounted_price)\n\n    total_price = round(sum(discounted_prices), 2)\n    print(f\"{total_price:.2f}\")\n\nsolve()",
      "first_seen": 1770994888.7085032,
      "last_seen": 1770999015.219215
    },
    "chain_reasoning:c651b538": {
      "task_signature": "chain_reasoning:c651b538",
      "category": "chain_reasoning",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    logs = []\n    for _ in range(n):\n        logs.append(input())\n\n    anomalies = 0\n    max_latency = 0\n    max_latency_index = -1\n    error_messages = []\n    critical_count = 0\n\n    for i, log in enumerate(logs):\n        parts = log.split()\n        level = parts[1]\n        message = \" \".join(parts[2:-1])\n        latency = int(parts[-1].split(\"=\")[1][:-2])\n\n        if level in [\"ERROR\", \"CRITICAL\"] or latency > 1000:\n            anomalies += 1\n\n        if latency > max_latency:\n            max_latency = latency\n            max_latency_index = i\n\n        if level in [\"ERROR\", \"CRITICAL\"]:\n            error_messages.append(message)\n        \n        if level == \"CRITICAL\":\n            critical_count += 1\n\n    from collections import Counter\n    if error_messages:\n        most_common_error = Counter(error_messages).most_common(1)[0][0]\n    else:\n        most_common_error = \"\"\n\n    print(anomalies)\n    print(max_latency_index, max_latency)\n    print(most_common_error)\n    print(critical_count)\n\nsolve()",
      "first_seen": 1770995211.3460453,
      "last_seen": 1770995211.346048
    },
    "chain_reasoning:2db2d9dd": {
      "task_signature": "chain_reasoning:2db2d9dd",
      "category": "chain_reasoning",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    data = []\n    for _ in range(n):\n        data.append(input())\n\n    valid_records = []\n    invalid_count = 0\n    for record in data:\n        name, age, salary, department = record.split(',')\n        age = int(age)\n        salary = int(salary)\n        if age >= 0 and salary >= 0:\n            valid_records.append((name, age, salary, department))\n        else:\n            invalid_count += 1\n\n    department_salaries = {}\n    for name, age, salary, department in valid_records:\n        if department not in department_salaries:\n            department_salaries[department] = []\n        department_salaries[department].append(salary)\n\n    department_avg_salaries = {}\n    for department, salaries in department_salaries.items():\n        department_avg_salaries[department] = sum(salaries) // len(salaries)\n\n    sorted_departments = sorted(department_avg_salaries.items(), key=lambda item: item[1], reverse=True)\n\n    print(len(valid_records))\n    print(invalid_count)\n    for department, avg_salary in sorted_departments:\n        print(department, avg_salary)\n\nsolve()",
      "first_seen": 1770995693.4302094,
      "last_seen": 1770995693.430212
    },
    "security_audit:44266447": {
      "task_signature": "security_audit:44266447",
      "category": "security_audit",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "def analyze_crypto_config():\n    config = {}\n    for _ in range(5):\n        line = input().strip()\n        key, value = line.split(': ')\n        config[key] = value\n\n    weaknesses = []\n\n    # WEAK_ALGORITHM\n    algorithm = config.get('algorithm', '').lower()\n    if algorithm in ['des', '3des']:\n        weaknesses.append('WEAK_ALGORITHM')\n\n    # SHORT_KEY\n    key_length_str = config.get('key_length', '')\n    if 'rsa' in algorithm:\n        key_length = int(algorithm.split('-')[1])\n        if key_length < 2048:\n            weaknesses.append('SHORT_KEY')\n    elif key_length_str:\n        key_length = int(key_length_str)\n        if key_length < 16:\n            weaknesses.append('SHORT_KEY')\n\n    # ECB_MODE\n    mode = config.get('mode', '').lower()\n    if mode == 'ecb':\n        weaknesses.append('ECB_MODE')\n\n    # IV_REUSE\n    iv_reuse = config.get('iv_reuse', '').lower()\n    if iv_reuse == 'true':\n        weaknesses.append('IV_REUSE')\n\n    # NO_PADDING\n    padding = config.get('padding', '').lower()\n    if padding == 'none':\n        weaknesses.append('NO_PADDING')\n\n    num_weaknesses = len(weaknesses)\n\n    if num_weaknesses == 0:\n        weakness_str = 'NONE'\n    else:\n        weakness_str = ' '.join(weaknesses)\n\n    if num_weaknesses >= 3:\n        severity = 'CRITICAL'\n    elif num_weaknesses >= 2:\n        severity = 'HIGH'\n    elif num_weaknesses >= 1:\n        severity = 'MEDIUM'\n    else:\n        severity = 'LOW'\n\n    print(num_weaknesses)\n    print(weakness_str)\n    print(severity)\n\nanalyze_crypto_config()",
      "first_seen": 1770995764.3878906,
      "last_seen": 1770997548.4492726
    },
    "devops_debug:86eb345a": {
      "task_signature": "devops_debug:86eb345a",
      "category": "devops_debug",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    stages = []\n    for _ in range(n):\n        stages.append(input())\n\n    problems = []\n    deploy_stage = None\n    test_stage_exists = False\n\n    stage_names = []\n    stage_dependencies = {}\n\n    for stage_str in stages:\n        parts = stage_str.split()\n        stage_name = parts[0]\n        stage_names.append(stage_name)\n\n        depends_part = parts[1]\n        depends_value = depends_part.split('=')[1]\n        stage_dependencies[stage_name] = depends_value\n\n        timeout_part = parts[2]\n        timeout_value = int(timeout_part.split('=')[1])\n\n        retry_part = parts[3]\n        retry_value = int(retry_part.split('=')[1])\n\n        if timeout_value == 0:\n            problems.append(f\"NO_TIMEOUT:{stage_name}\")\n        if stage_name.startswith(\"deploy\") and retry_value > 0:\n            problems.append(f\"DEPLOY_RETRY:{stage_name}\")\n            deploy_stage = stage_name\n        if stage_name.startswith(\"test\"):\n            test_stage_exists = True\n\n    if deploy_stage:\n        deploy_depends_on = stage_dependencies[deploy_stage]\n        if deploy_depends_on == 'none' or 'test' not in stage_names:\n            \n            test_before_deploy = False\n            \n            current_stage = deploy_stage\n            \n            while current_stage != 'none':\n                \n                if current_stage in stage_dependencies:\n                    \n                    if 'test' in stage_dependencies[current_stage]:\n                        test_before_deploy = True\n                        break\n                    \n                    current_stage = stage_dependencies[current_stage]\n                    \n                    if current_stage == 'none':\n                        break\n                else:\n                    break\n            \n            if not test_stage_exists:\n                problems.append(\"DEPLOY_WITHOUT_TEST\")\n            elif not test_before_deploy and 'test' not in deploy_depends_on:\n                problems.append(\"DEPLOY_WITHOUT_TEST\")\n                \n    elif test_stage_exists and not any(stage.startswith(\"deploy\") for stage in stage_names):\n        pass\n    else:\n        pass\n\n    num_problems = len(problems)\n    print(num_problems)\n    if num_problems == 0:\n        print(\"NONE\")\n    else:\n        for problem in problems:\n            print(problem)\n\nsolve()",
      "first_seen": 1770995777.5010657,
      "last_seen": 1770997913.2510111
    },
    "chain_reasoning:0f62b1e6": {
      "task_signature": "chain_reasoning:0f62b1e6",
      "category": "chain_reasoning",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    logs = []\n    for _ in range(n):\n        logs.append(input())\n\n    anomalies = 0\n    max_latency = 0\n    max_latency_index = 0\n    error_messages = {}\n    critical_count = 0\n\n    for i, log in enumerate(logs):\n        parts = log.split()\n        level = parts[1]\n        message = \" \".join(parts[2:-1])\n        latency = int(parts[-1].split('=')[1][:-2])\n\n        if level in [\"ERROR\", \"CRITICAL\"] or latency > 1000:\n            anomalies += 1\n\n        if latency > max_latency:\n            max_latency = latency\n            max_latency_index = i\n\n        if level in [\"ERROR\", \"CRITICAL\"]:\n            if message in error_messages:\n                error_messages[message] += 1\n            else:\n                error_messages[message] = 1\n\n        if level == \"CRITICAL\":\n            critical_count += 1\n\n    most_common_error = \"\"\n    max_count = 0\n    for message, count in error_messages.items():\n        if count > max_count:\n            most_common_error = message\n            max_count = count\n\n    print(anomalies)\n    print(max_latency_index, max_latency)\n    if most_common_error:\n        print(most_common_error)\n    else:\n        print(\"\")\n    print(critical_count)\n\nsolve()",
      "first_seen": 1770995839.856935,
      "last_seen": 1771000087.900873
    },
    "massive_scale:95a89d91": {
      "task_signature": "massive_scale:95a89d91",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "def solve():\n    n_files = int(input())\n    files_data = []\n    for _ in range(n_files):\n        line = input().split()\n        filename = line[0]\n        rows = int(line[1])\n        functions = int(line[2])\n        classes = int(line[3])\n        imports = int(line[4])\n        complexity = int(line[5])\n        files_data.append((filename, rows, functions, classes, imports, complexity))\n\n    total_rows = sum(file[1] for file in files_data)\n    total_functions = sum(file[2] for file in files_data)\n    total_classes = sum(file[3] for file in files_data)\n\n    print(f\"{total_rows} {total_functions} {total_classes}\")\n\n    total_complexity = sum(file[5] for file in files_data)\n    mean_complexity = total_complexity / n_files\n    print(f\"{mean_complexity:.1f}\")\n\n    most_complex_file = max(files_data, key=lambda x: x[5])\n    print(f\"{most_complex_file[0]} {most_complex_file[5]}\")\n\n    largest_file = max(files_data, key=lambda x: x[1])\n    print(f\"{largest_file[0]} {largest_file[1]}\")\n\n    files_with_high_complexity = sum(1 for file in files_data if file[5] > 10)\n    print(files_with_high_complexity)\n\n    files_with_many_imports = sum(1 for file in files_data if file[4] > 10)\n    print(files_with_many_imports)\n\nsolve()",
      "first_seen": 1770995856.9649036,
      "last_seen": 1770999986.9687424
    },
    "devops_debug:5dc9a562": {
      "task_signature": "devops_debug:5dc9a562",
      "category": "devops_debug",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    rules = []\n    for _ in range(n):\n        rules.append(input().split())\n\n    port_actions = {}\n    for action, protocol, port, source in rules:\n        port = int(port)\n        if port not in port_actions:\n            port_actions[port] = {'ALLOW': 0, 'DENY': 0}\n        port_actions[port][action] += 1\n\n    conflicting_ports = []\n    for port, actions in port_actions.items():\n        if actions['ALLOW'] > 0 and actions['DENY'] > 0:\n            conflicting_ports.append(port)\n\n    conflicting_ports.sort()\n    \n    dangerous_ports = [22, 3306, 5432, 6379, 27017]\n    dangerous_rules_count = 0\n    dangerous_ports_found = []\n    \n    for action, protocol, port, source in rules:\n        port = int(port)\n        if action == 'ALLOW' and source == '0.0.0.0/0' and port in dangerous_ports:\n            dangerous_rules_count += 1\n            if port not in dangerous_ports_found:\n                dangerous_ports_found.append(port)\n    \n    dangerous_ports_found.sort()\n    \n    print(len(conflicting_ports))\n    if conflicting_ports:\n        print(*conflicting_ports)\n    else:\n        print(\"none\")\n    \n    print(dangerous_rules_count)\n    if dangerous_ports_found:\n        print(*dangerous_ports_found)\n    else:\n        print(\"none\")\n\nsolve()",
      "first_seen": 1770995873.8276508,
      "last_seen": 1770995873.8276525
    },
    "real_world_auto:4cc102fd": {
      "task_signature": "real_world_auto:4cc102fd",
      "category": "real_world_auto",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "import json\n\ndata = []\ntry:\n    num_items = int(input())\n    for _ in range(num_items):\n        data.append(json.loads(input()))\nexcept ValueError:\n    print(\"Invalid input for number of items.\")\n    exit()\nexcept json.JSONDecodeError:\n    print(\"Invalid JSON input.\")\n    exit()\n\nprint(\"name,category,price,qty\")\nfor item in data:\n    print(f\"{item['name']},{item['category']},{item['price']:.2f},{item['qty']}\")\n\nprint(\"---\")\n\ncategory_data = {}\nfor item in data:\n    category = item['category']\n    revenue = item['price'] * item['qty']\n    qty = item['qty']\n    if category in category_data:\n        category_data[category]['revenue'] += revenue\n        category_data[category]['qty'] += qty\n    else:\n        category_data[category] = {'revenue': revenue, 'qty': qty}\n\nsorted_categories = sorted(category_data.items(), key=lambda item: item[1]['revenue'], reverse=True)\n\nfor category, values in sorted_categories:\n    print(f\"{category} {values['revenue']:.2f} {values['qty']}\")",
      "first_seen": 1770995910.7000465,
      "last_seen": 1770995910.7000484
    },
    "massive_scale:63ad8a37": {
      "task_signature": "massive_scale:63ad8a37",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n_files = int(input())\n    \n    rows = []\n    functions = []\n    classes = []\n    complexities = []\n    imports_list = []\n    filenames = []\n    \n    for _ in range(n_files):\n        line = input().split()\n        filename = line[0]\n        row = int(line[1])\n        function = int(line[2])\n        class_ = int(line[3])\n        imports = int(line[4])\n        complexity = int(line[5])\n        \n        filenames.append(filename)\n        rows.append(row)\n        functions.append(function)\n        classes.append(class_)\n        complexities.append(complexity)\n        imports_list.append(imports)\n    \n    total_rows = sum(rows)\n    total_functions = sum(functions)\n    total_classes = sum(classes)\n    \n    print(total_rows, total_functions, total_classes)\n    \n    avg_complexity = sum(complexities) / len(complexities)\n    print(f\"{avg_complexity:.1f}\")\n    \n    max_complexity = max(complexities)\n    max_complexity_index = complexities.index(max_complexity)\n    max_complexity_filename = filenames[max_complexity_index]\n    print(f\"{max_complexity_filename} {max_complexity}\")\n    \n    max_rows = max(rows)\n    max_rows_index = rows.index(max_rows)\n    max_rows_filename = filenames[max_rows_index]\n    print(f\"{max_rows_filename} {max_rows}\")\n    \n    count_complexity_gt_10 = sum(1 for complexity in complexities if complexity > 10)\n    print(count_complexity_gt_10)\n    \n    count_imports_gt_10 = sum(1 for imports in imports_list if imports > 10)\n    print(count_imports_gt_10)\n\nsolve()",
      "first_seen": 1770996079.5897157,
      "last_seen": 1770996079.589718
    },
    "real_world_auto:51c669bf": {
      "task_signature": "real_world_auto:51c669bf",
      "category": "real_world_auto",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "import json\n\ndef main():\n    n = int(input())\n    data = []\n    for _ in range(n):\n        try:\n            data.append(json.loads(input()))\n        except json.JSONDecodeError:\n            continue\n\n    print(\"name,category,price,qty\")\n    for item in data:\n        print(f\"{item['name']},{item['category']},{item['price']:.2f},{item['qty']}\")\n\n    print(\"---\")\n\n    category_data = {}\n    for item in data:\n        category = item['category']\n        price = item['price']\n        qty = item['qty']\n        if category not in category_data:\n            category_data[category] = {'revenue': 0, 'qty': 0}\n        category_data[category]['revenue'] += price * qty\n        category_data[category]['qty'] += qty\n\n    sorted_categories = sorted(category_data.items(), key=lambda item: item[1]['revenue'], reverse=True)\n\n    for category, values in sorted_categories:\n        print(f\"{category} {values['revenue']:.2f} {values['qty']}\")\n\nif __name__ == \"__main__\":\n    main()",
      "first_seen": 1770996311.0536685,
      "last_seen": 1770996311.0536711
    },
    "massive_scale:97c604cd": {
      "task_signature": "massive_scale:97c604cd",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n, k = map(int, input().split())\n    nums = []\n    for _ in range(n):\n        nums.append(int(input()))\n\n    max_sum = float('-inf')\n    current_sum = sum(nums[:k])\n    max_sum = current_sum\n\n    for i in range(n - k):\n        current_sum = current_sum - nums[i] + nums[i + k]\n        max_sum = max(max_sum, current_sum)\n\n    print(max_sum)\n\nsolve()",
      "first_seen": 1770996351.1446595,
      "last_seen": 1770996351.1446626
    },
    "devops_debug:f73927c6": {
      "task_signature": "devops_debug:f73927c6",
      "category": "devops_debug",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def ip_to_int(ip_str):\n    octets = map(int, ip_str.split('.'))\n    return sum(octet << (8*(3-i)) for i, octet in enumerate(octets))\n\ndef subnet_mask(cidr):\n    return (0xFFFFFFFF << (32 - cidr)) & 0xFFFFFFFF\n\ndef network_addr(ip_int, mask):\n    return ip_int & mask\n\ndef int_to_ip(n):\n    return '.'.join(str((n >> (8*(3-i))) & 0xFF) for i in range(4))\n\nn = int(input())\nrules = []\nfor _ in range(n):\n    rules.append(input().split())\n\nport_actions = {}\nfor action, proto, port, source in rules:\n    port = int(port)\n    if port not in port_actions:\n        port_actions[port] = {'ALLOW': [], 'DENY': []}\n    port_actions[port][action].append(source)\n\nconflict_ports = []\nfor port, actions in port_actions.items():\n    if actions['ALLOW'] and actions['DENY']:\n        conflict_ports.append(port)\n\nconflict_ports.sort()\n\ndangerous_ports = [22, 3306, 5432, 6379, 27017]\ndangerous_rules_count = 0\ndangerous_ports_found = []\n\nfor action, proto, port, source in rules:\n    port = int(port)\n    if action == 'ALLOW' and port in dangerous_ports and source == '0.0.0.0/0':\n        dangerous_rules_count += 1\n        dangerous_ports_found.append(port)\n\ndangerous_ports_found = sorted(list(set(dangerous_ports_found)))\n\nprint(len(conflict_ports))\nif conflict_ports:\n    print(*conflict_ports, sep=' ')\nelse:\n    print('none')\n\nprint(dangerous_rules_count)\nif dangerous_ports_found:\n    print(*dangerous_ports_found, sep=' ')\nelse:\n    print('none')",
      "first_seen": 1770996372.678325,
      "last_seen": 1770996372.6783266
    },
    "chain_reasoning:b11eb558": {
      "task_signature": "chain_reasoning:b11eb558",
      "category": "chain_reasoning",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    logs = []\n    for _ in range(n):\n        logs.append(input())\n\n    anomalies = 0\n    max_latency = 0\n    max_latency_index = -1\n    error_messages = []\n    critical_count = 0\n\n    for i, log in enumerate(logs):\n        parts = log.split()\n        level = parts[1]\n        message = \" \".join(parts[2:-1])\n        latency = int(parts[-1].split('=')[1][:-2])\n\n        if level in [\"ERROR\", \"CRITICAL\"] or latency > 1000:\n            anomalies += 1\n\n        if latency > max_latency:\n            max_latency = latency\n            max_latency_index = i\n\n        if level in [\"ERROR\", \"CRITICAL\"]:\n            error_messages.append(message)\n\n        if level == \"CRITICAL\":\n            critical_count += 1\n\n    from collections import Counter\n    if error_messages:\n        most_common_error = Counter(error_messages).most_common(1)[0][0]\n    else:\n        most_common_error = \"\"\n\n    print(anomalies)\n    print(max_latency_index, max_latency)\n    if most_common_error:\n        print(most_common_error)\n    else:\n        print(\"\")\n    print(critical_count)\n\nsolve()",
      "first_seen": 1770997434.8468435,
      "last_seen": 1770997434.846846
    },
    "massive_scale:da574480": {
      "task_signature": "massive_scale:da574480",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n, k = map(int, input().split())\n    nums = []\n    for _ in range(n):\n        nums.append(int(input()))\n\n    if k > n:\n        print(0)\n        return\n\n    max_sum = float('-inf')\n    current_sum = sum(nums[:k])\n    max_sum = current_sum\n\n    for i in range(k, n):\n        current_sum += nums[i] - nums[i - k]\n        max_sum = max(max_sum, current_sum)\n\n    print(max_sum)\n\nsolve()",
      "first_seen": 1770997449.7611613,
      "last_seen": 1770997449.7611637
    },
    "chain_reasoning:4da69c37": {
      "task_signature": "chain_reasoning:4da69c37",
      "category": "chain_reasoning",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    lines = []\n    for _ in range(20):\n        lines.append(input())\n\n    valid_rows = 0\n    invalid_rows = 0\n    salaries_by_department = {}\n\n    for line in lines:\n        parts = line.split(',')\n        if len(parts) != 4:\n            invalid_rows += 1\n            continue\n\n        name, age_str, salary_str, department = parts\n        \n        try:\n            age = int(age_str)\n            salary = int(salary_str)\n        except ValueError:\n            invalid_rows += 1\n            continue\n\n        if age >= 0 and salary >= 0:\n            valid_rows += 1\n            if department not in salaries_by_department:\n                salaries_by_department[department] = []\n            salaries_by_department[department].append(salary)\n        else:\n            invalid_rows += 1\n\n    avg_salaries = {}\n    for department, salaries in salaries_by_department.items():\n        if salaries:\n            avg_salaries[department] = sum(salaries) // len(salaries)\n        else:\n            avg_salaries[department] = 0\n\n    sorted_departments = sorted(avg_salaries.items(), key=lambda item: item[1], reverse=True)\n\n    print(valid_rows)\n    print(invalid_rows)\n    for department, avg_salary in sorted_departments:\n        print(f\"{department} {avg_salary}\")\n\nsolve()",
      "first_seen": 1770997495.7349093,
      "last_seen": 1770997495.734911
    },
    "cross_domain:0c7378a4": {
      "task_signature": "cross_domain:0c7378a4",
      "category": "cross_domain",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "n = int(input())\nx_vals, y_vals = [], []\nfor _ in range(n):\n    parts = input().split()\n    x_vals.append(float(parts[0]))\n    y_vals.append(float(parts[1]))\nx_new = float(input())\n\nx_mean = sum(x_vals) / n\ny_mean = sum(y_vals) / n\nss_xy = sum((x - x_mean) * (y - y_mean) for x, y in zip(x_vals, y_vals))\nss_xx = sum((x - x_mean) ** 2 for x in x_vals)\nslope = ss_xy / ss_xx\nintercept = y_mean - slope * x_mean\n\nss_res = sum((y - (slope * x + intercept)) ** 2 for x, y in zip(x_vals, y_vals))\nss_tot = sum((y - y_mean) ** 2 for y in y_vals)\nr_squared = 1 - ss_res / ss_tot if ss_tot != 0 else 0\n\ny_pred = slope * x_new + intercept\nprint(f'{slope:.4f}')\nprint(f'{intercept:.4f}')\nprint(f'{r_squared:.4f}')\nprint(f'{y_pred:.4f}')",
      "first_seen": 1770997535.7449083,
      "last_seen": 1770997535.7449105
    },
    "cross_domain:848a02ae": {
      "task_signature": "cross_domain:848a02ae",
      "category": "cross_domain",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "n = int(input())\nx_vals, y_vals = [], []\nfor _ in range(n):\n    parts = input().split()\n    x_vals.append(float(parts[0]))\n    y_vals.append(float(parts[1]))\nx_new = float(input())\n\nx_mean = sum(x_vals) / n\ny_mean = sum(y_vals) / n\nss_xy = sum((x - x_mean) * (y - y_mean) for x, y in zip(x_vals, y_vals))\nss_xx = sum((x - x_mean) ** 2 for x in x_vals)\nslope = ss_xy / ss_xx\nintercept = y_mean - slope * x_mean\n\nss_res = sum((y - (slope * x + intercept)) ** 2 for x, y in zip(x_vals, y_vals))\nss_tot = sum((y - y_mean) ** 2 for y in y_vals)\nr_squared = 1 - ss_res / ss_tot if ss_tot != 0 else 0\n\ny_pred = slope * x_new + intercept\nprint(f'{slope:.4f}')\nprint(f'{intercept:.4f}')\nprint(f'{r_squared:.4f}')\nprint(f'{y_pred:.4f}')",
      "first_seen": 1770997794.7348163,
      "last_seen": 1770997794.7348194
    },
    "massive_scale:d8218445": {
      "task_signature": "massive_scale:d8218445",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n, k = map(int, input().split())\n    arr = []\n    for _ in range(n):\n        arr.append(int(input()))\n\n    max_sum = float('-inf')\n    current_sum = sum(arr[:k])\n    max_sum = current_sum\n\n    for i in range(1, n - k + 1):\n        current_sum = current_sum - arr[i - 1] + arr[i + k - 1]\n        max_sum = max(max_sum, current_sum)\n\n    print(max_sum)\n\nsolve()",
      "first_seen": 1770997840.41025,
      "last_seen": 1770997840.4102516
    },
    "real_world_auto:cace7482": {
      "task_signature": "real_world_auto:cace7482",
      "category": "real_world_auto",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    \n    results = []\n    total_success = 0\n    total_requests = n\n    total_attempts = 0\n\n    for _ in range(n):\n        line = input().split()\n        url = line[0]\n        statuses = [int(s) for s in line[1:]]\n        \n        attempts = 0\n        backoff = 0\n        current_backoff = 1\n        final_status = None\n        \n        for status in statuses:\n            attempts += 1\n            total_attempts += 1\n            \n            if status == 200:\n                total_success += 1\n                final_status = 200\n                break\n            elif status in [429, 500, 503]:\n                backoff += current_backoff\n                current_backoff *= 2\n            else:\n                final_status = status\n                break\n        \n        if final_status is None:\n            final_status = statuses[-1]\n            \n        results.append((url, final_status, attempts, backoff))\n\n    print(f\"{total_success}/{total_requests}\")\n    print(total_attempts)\n    \n    for url, status, attempts, backoff in results:\n        print(f\"{url} {status} {attempts} {backoff}s\")\n\nsolve()",
      "first_seen": 1770997894.4417715,
      "last_seen": 1770997894.4417727
    },
    "chain_reasoning:b350ae0b": {
      "task_signature": "chain_reasoning:b350ae0b",
      "category": "chain_reasoning",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    logs = []\n    for _ in range(n):\n        logs.append(input())\n\n    anomalies = 0\n    max_latency = 0\n    max_latency_index = -1\n    error_messages = []\n    critical_count = 0\n\n    for i, log in enumerate(logs):\n        parts = log.split()\n        level = parts[1]\n        message = \" \".join(parts[2:-1])\n        latency = int(parts[-1].split('=')[1][:-2])\n\n        if level in (\"ERROR\", \"CRITICAL\") or latency > 1000:\n            anomalies += 1\n\n        if latency > max_latency:\n            max_latency = latency\n            max_latency_index = i\n\n        if level in (\"ERROR\", \"CRITICAL\"):\n            error_messages.append(message)\n        \n        if level == \"CRITICAL\":\n            critical_count += 1\n\n    from collections import Counter\n    if error_messages:\n        most_common_error = Counter(error_messages).most_common(1)[0][0]\n    else:\n        most_common_error = \"\"\n\n    print(anomalies)\n    print(max_latency_index, max_latency)\n    print(most_common_error)\n    print(critical_count)\n\nsolve()",
      "first_seen": 1770997903.1302633,
      "last_seen": 1770999044.108469
    },
    "massive_scale:b2af1ee7": {
      "task_signature": "massive_scale:b2af1ee7",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n_files = int(input())\n    \n    files_data = []\n    for _ in range(n_files):\n        line = input().split()\n        filename = line[0]\n        rows = int(line[1])\n        functions = int(line[2])\n        classes = int(line[3])\n        imports = int(line[4])\n        complexity = int(line[5])\n        files_data.append((filename, rows, functions, classes, imports, complexity))\n    \n    total_rows = sum(file[1] for file in files_data)\n    total_functions = sum(file[2] for file in files_data)\n    total_classes = sum(file[3] for file in files_data)\n    \n    print(f\"{total_rows} {total_functions} {total_classes}\")\n    \n    total_complexity = sum(file[5] for file in files_data)\n    mean_complexity = total_complexity / n_files\n    print(f\"{mean_complexity:.1f}\")\n    \n    most_complex_file = max(files_data, key=lambda x: x[5])\n    print(f\"{most_complex_file[0]} {most_complex_file[5]}\")\n    \n    largest_file = max(files_data, key=lambda x: x[1])\n    print(f\"{largest_file[0]} {largest_file[1]}\")\n    \n    files_complex_gt_10 = len([file for file in files_data if file[5] > 10])\n    print(files_complex_gt_10)\n    \n    files_imports_gt_10 = len([file for file in files_data if file[4] > 10])\n    print(files_imports_gt_10)\n\nsolve()",
      "first_seen": 1770998002.7781034,
      "last_seen": 1770998002.7781048
    },
    "security_audit:eafb5103": {
      "task_signature": "security_audit:eafb5103",
      "category": "security_audit",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 0,
      "consecutive_successes": 0,
      "failures": 0,
      "best_code": "",
      "first_seen": 1770998550.3269277,
      "last_seen": 1770998550.326928
    },
    "chain_reasoning:3b49ce97": {
      "task_signature": "chain_reasoning:3b49ce97",
      "category": "chain_reasoning",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    data = []\n    for _ in range(n):\n        data.append(input())\n\n    valid_records = []\n    invalid_count = 0\n    for record in data:\n        name, age, salary, department = record.split(',')\n        age = int(age)\n        salary = int(salary)\n        if age >= 0 and salary >= 0:\n            valid_records.append((name, age, salary, department))\n        else:\n            invalid_count += 1\n\n    valid_count = len(valid_records)\n\n    department_salaries = {}\n    for name, age, salary, department in valid_records:\n        if department not in department_salaries:\n            department_salaries[department] = []\n        department_salaries[department].append(salary)\n\n    department_avg_salaries = {}\n    for department, salaries in department_salaries.items():\n        department_avg_salaries[department] = sum(salaries) // len(salaries)\n\n    sorted_departments = sorted(department_avg_salaries.items(), key=lambda item: item[1], reverse=True)\n\n    print(valid_count)\n    print(invalid_count)\n    for department, avg_salary in sorted_departments:\n        print(f\"{department} {avg_salary}\")\n\nsolve()",
      "first_seen": 1770998908.0231867,
      "last_seen": 1770998908.0231895
    },
    "massive_scale:8c9ef11c": {
      "task_signature": "massive_scale:8c9ef11c",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n, k = map(int, input().split())\n    arr = []\n    for _ in range(n):\n        arr.append(int(input()))\n\n    max_sum = float('-inf')\n    current_sum = sum(arr[:k])\n    max_sum = current_sum\n\n    for i in range(1, n - k + 1):\n        current_sum = current_sum - arr[i - 1] + arr[i + k - 1]\n        max_sum = max(max_sum, current_sum)\n\n    print(max_sum)\n\nsolve()",
      "first_seen": 1770999147.853476,
      "last_seen": 1770999147.8534794
    },
    "massive_scale:b3f07a39": {
      "task_signature": "massive_scale:b3f07a39",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n_files = int(input())\n    \n    lines = []\n    functions = []\n    classes = []\n    complexities = []\n    filenames = []\n    imports = []\n    \n    for _ in range(n_files):\n        line = input().split()\n        filename = line[0]\n        num_lines = int(line[1])\n        num_functions = int(line[2])\n        num_classes = int(line[3])\n        num_imports = int(line[4])\n        complexity = int(line[5])\n        \n        filenames.append(filename)\n        lines.append(num_lines)\n        functions.append(num_functions)\n        classes.append(num_classes)\n        imports.append(num_imports)\n        complexities.append(complexity)\n        \n    total_lines = sum(lines)\n    total_functions = sum(functions)\n    total_classes = sum(classes)\n    \n    avg_complexity = sum(complexities) / n_files\n    \n    max_complexity = max(complexities)\n    max_complexity_index = complexities.index(max_complexity)\n    max_complexity_filename = filenames[max_complexity_index]\n    \n    max_lines = max(lines)\n    max_lines_index = lines.index(max_lines)\n    max_lines_filename = filenames[max_lines_index]\n    \n    complex_files = len([c for c in complexities if c > 10])\n    import_files = len([i for i in imports if i > 10])\n    \n    print(f\"{total_lines} {total_functions} {total_classes}\")\n    print(f\"{avg_complexity:.1f}\")\n    print(f\"{max_complexity_filename} {max_complexity}\")\n    print(f\"{max_lines_filename} {max_lines}\")\n    print(complex_files)\n    print(import_files)\n\nsolve()",
      "first_seen": 1770999773.5569203,
      "last_seen": 1770999773.5569227
    },
    "real_world_auto:6cb7a73b": {
      "task_signature": "real_world_auto:6cb7a73b",
      "category": "real_world_auto",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "import json\n\nitems = []\nnum_items = int(input())\nfor _ in range(num_items):\n    try:\n        item = json.loads(input())\n        items.append(item)\n    except json.JSONDecodeError:\n        print(\"Invalid JSON input\")\n        exit()\n\nprint(\"name,category,price,qty\")\nfor item in items:\n    try:\n        print(f\"{item['name']},{item['category']},{float(item['price']):.2f},{item['qty']}\")\n    except (KeyError, ValueError, TypeError) as e:\n        print(f\"Error processing item: {item}. Missing key or incorrect type. Error: {e}\")\n        exit()\n\nprint(\"---\")\n\ncategory_data = {}\nfor item in items:\n    try:\n        category = item['category']\n        price = float(item['price'])\n        qty = int(item['qty'])\n        revenue = price * qty\n        if category in category_data:\n            category_data[category]['revenue'] += revenue\n            category_data[category]['qty'] += qty\n        else:\n            category_data[category] = {'revenue': revenue, 'qty': qty}\n    except (KeyError, ValueError, TypeError) as e:\n        print(f\"Error processing item: {item}. Missing key or incorrect type. Error: {e}\")\n        exit()\n\nsorted_categories = sorted(category_data.items(), key=lambda item: item[1]['revenue'], reverse=True)\n\nfor category, data in sorted_categories:\n    print(f\"{category} {data['revenue']:.2f} {data['qty']}\")",
      "first_seen": 1770999904.33896,
      "last_seen": 1770999904.3389633
    },
    "adversarial:abf668a3": {
      "task_signature": "adversarial:abf668a3",
      "category": "adversarial",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    events = []\n    for _ in range(n):\n        events.append(input().split())\n\n    locks = {}  # resource: thread\n    problems = []\n\n    def add_problem(problem):\n        if problem not in problems:\n            problems.append(problem)\n\n    for thread, action, resource in events:\n        if action == \"LOCK\":\n            if resource in locks and locks[resource] != thread:\n                add_problem(f\"DEADLOCK_RISK:{thread}:{resource}\")\n            else:\n                locks[resource] = thread\n        elif action == \"UNLOCK\":\n            if resource in locks and locks[resource] == thread:\n                del locks[resource]\n        elif action == \"READ\":\n            if resource in locks and locks[resource] != thread:\n                add_problem(f\"RACE:{thread}:{action}:{resource}\")\n        elif action == \"WRITE\":\n            if resource in locks and locks[resource] != thread:\n                add_problem(f\"RACE:{thread}:{action}:{resource}\")\n            if resource not in locks:\n                add_problem(f\"UNPROTECTED_WRITE:{thread}:{resource}\")\n\n    print(len(problems))\n    if not problems:\n        print(\"NONE\")\n    else:\n        for problem in problems:\n            print(problem)\n\nsolve()",
      "first_seen": 1771000008.2463555,
      "last_seen": 1771000008.246357
    },
    "adversarial:0b257048": {
      "task_signature": "adversarial:0b257048",
      "category": "adversarial",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 0,
      "consecutive_successes": 0,
      "failures": 0,
      "best_code": "",
      "first_seen": 1771000017.3596041,
      "last_seen": 1771000017.3596046
    },
    "chain_reasoning:d28a3c8f": {
      "task_signature": "chain_reasoning:d28a3c8f",
      "category": "chain_reasoning",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    data = []\n    for _ in range(n):\n        data.append(input())\n\n    # STEG 1 — PARSA INPUT:\n    parsed_data = []\n    for row in data:\n        try:\n            name, age, salary, department = row.split(',')\n            age = int(age)\n            salary = int(salary)\n            parsed_data.append((name, age, salary, department))\n        except ValueError:\n            pass\n\n    # STEG 2 — VALIDERA:\n    valid_data = []\n    invalid_count = 0\n    for name, age, salary, department in parsed_data:\n        if age >= 0 and salary >= 0:\n            valid_data.append((name, age, salary, department))\n        else:\n            invalid_count += 1\n\n    valid_count = len(valid_data)\n\n    # STEG 3 — AGGREGERA:\n    department_salaries = {}\n    for name, age, salary, department in valid_data:\n        if department not in department_salaries:\n            department_salaries[department] = []\n        department_salaries[department].append(salary)\n\n    department_avg_salaries = {}\n    for department, salaries in department_salaries.items():\n        department_avg_salaries[department] = sum(salaries) // len(salaries)\n\n    # STEG 4 — SORTERA:\n    sorted_departments = sorted(department_avg_salaries.items(), key=lambda item: item[1], reverse=True)\n\n    # STEG 5 — OUTPUT:\n    print(valid_count)\n    print(invalid_count)\n    for department, avg_salary in sorted_departments:\n        print(f\"{department} {avg_salary}\")\n\nsolve()",
      "first_seen": 1771000061.3924685,
      "last_seen": 1771000061.3924708
    },
    "chain_reasoning:5fdf8b19": {
      "task_signature": "chain_reasoning:5fdf8b19",
      "category": "chain_reasoning",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    expression = input()\n    tokens = expression.split()\n    \n    num_tokens = len(tokens)\n    num_numbers = 0\n    num_operators = 0\n    \n    for token in tokens:\n        if token.isdigit():\n            num_numbers += 1\n        elif token in ['+', '-', '*']:\n            num_operators += 1\n            \n    def evaluate(tokens):\n        values = []\n        ops = []\n        \n        i = 0\n        while i < len(tokens):\n            if tokens[i].isdigit():\n                values.append(int(tokens[i]))\n            elif tokens[i] in ['+', '-', '*']:\n                while ops and precedence(ops[-1]) >= precedence(tokens[i]):\n                    val2 = values.pop()\n                    val1 = values.pop()\n                    op = ops.pop()\n                    values.append(apply_op(val1, val2, op))\n                ops.append(tokens[i])\n            i += 1\n        \n        while ops:\n            val2 = values.pop()\n            val1 = values.pop()\n            op = ops.pop()\n            values.append(apply_op(val1, val2, op))\n        \n        return values[0]\n\n    def precedence(op):\n        if op == '*':\n            return 2\n        elif op in ['+', '-']:\n            return 1\n        return 0\n\n    def apply_op(a, b, op):\n        if op == '+':\n            return a + b\n        elif op == '-':\n            return a - b\n        elif op == '*':\n            return a * b\n        return 0\n    \n    result = evaluate(tokens)\n    \n    print(num_tokens)\n    print(num_numbers, num_operators)\n    print(result)\n\nsolve()",
      "first_seen": 1771000119.5220637,
      "last_seen": 1771000119.5220659
    },
    "massive_scale:aa705271": {
      "task_signature": "massive_scale:aa705271",
      "category": "massive_scale",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n, k = map(int, input().split())\n    nums = []\n    for _ in range(n):\n        nums.append(int(input()))\n\n    max_sum = float('-inf')\n    current_sum = sum(nums[:k])\n    max_sum = current_sum\n\n    for i in range(k, n):\n        current_sum += nums[i] - nums[i - k]\n        max_sum = max(max_sum, current_sum)\n\n    print(max_sum)\n\nsolve()",
      "first_seen": 1771000155.6765058,
      "last_seen": 1771000155.6765075
    },
    "bugfix:367cb0fb": {
      "task_signature": "bugfix:367cb0fb",
      "category": "bugfix",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 7,
      "consecutive_successes": 7,
      "failures": 0,
      "best_code": "def binary_search(arr, target):\n    lo, hi = 0, len(arr) - 1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n    return -1\n\nif __name__ == \"__main__\":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    target = int(input())\n    print(binary_search(arr, target))",
      "first_seen": 1771003672.0587573,
      "last_seen": 1771146529.9043164
    },
    "refactor_functional:ec0822bd": {
      "task_signature": "refactor_functional:ec0822bd",
      "category": "refactor_functional",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "import math\n\nn = int(input())\nnums = [int(input()) for _ in range(n)]\nprint(math.prod(nums))",
      "first_seen": 1771003713.3535826,
      "last_seen": 1771003713.3535855
    },
    "refactor_list:3f10bbdb": {
      "task_signature": "refactor_list:3f10bbdb",
      "category": "refactor_list",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    numbers = [int(input()) for _ in range(n)]\n    print(max(numbers) - min(numbers))\n\nsolve()",
      "first_seen": 1771003725.4528086,
      "last_seen": 1771160363.8902419
    },
    "basics:dd71f62a": {
      "task_signature": "basics:dd71f62a",
      "category": "basics",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "print(\"Hello, World!\")",
      "first_seen": 1771003765.3752882,
      "last_seen": 1771003765.375291
    },
    "basics:6a9427cf": {
      "task_signature": "basics:6a9427cf",
      "category": "basics",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "line = input()\nprint(line)",
      "first_seen": 1771003768.063178,
      "last_seen": 1771003768.0631807
    },
    "basics:8a057c42": {
      "task_signature": "basics:8a057c42",
      "category": "basics",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "a = int(input())\nb = int(input())\nprint(a + b)",
      "first_seen": 1771003772.9579303,
      "last_seen": 1771003772.9579344
    },
    "basics:e7da780b": {
      "task_signature": "basics:e7da780b",
      "category": "basics",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "width = int(input())\nheight = int(input())\narea = width * height\nprint(area)",
      "first_seen": 1771003778.4475732,
      "last_seen": 1771003778.4475758
    },
    "basics:43972de7": {
      "task_signature": "basics:43972de7",
      "category": "basics",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "celsius = int(input())\nfahrenheit = celsius * 9 // 5 + 32\nprint(fahrenheit)",
      "first_seen": 1771003781.663944,
      "last_seen": 1771003781.6639514
    },
    "control:6216548b": {
      "task_signature": "control:6216548b",
      "category": "control",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "n = int(input())\nif n % 2 == 0:\n  print('even')\nelse:\n  print('odd')",
      "first_seen": 1771003784.9386292,
      "last_seen": 1771003784.9386318
    },
    "control:607c75db": {
      "task_signature": "control:607c75db",
      "category": "control",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "a = int(input())\nb = int(input())\nc = int(input())\n\nif a >= b and a >= c:\n  print(a)\nelif b >= a and b >= c:\n  print(b)\nelse:\n  print(c)",
      "first_seen": 1771003789.6691804,
      "last_seen": 1771003789.6691833
    },
    "control:3fa65974": {
      "task_signature": "control:3fa65974",
      "category": "control",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "n = int(input())\n\nif n % 3 == 0 and n % 5 == 0:\n  print('FizzBuzz')\nelif n % 3 == 0:\n  print('Fizz')\nelif n % 5 == 0:\n  print('Buzz')\nelse:\n  print(n)",
      "first_seen": 1771003793.9882963,
      "last_seen": 1771003793.988299
    },
    "control:8393db5f": {
      "task_signature": "control:8393db5f",
      "category": "control",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "n = int(input())\nfor i in range(1, n + 1):\n  print(i)",
      "first_seen": 1771003808.289749,
      "last_seen": 1771003808.2897518
    },
    "control:283ad55a": {
      "task_signature": "control:283ad55a",
      "category": "control",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "n = int(input())\nsum_numbers = sum(range(1, n + 1))\nprint(sum_numbers)",
      "first_seen": 1771003812.3322937,
      "last_seen": 1771003812.3322973
    },
    "control:f8853347": {
      "task_signature": "control:f8853347",
      "category": "control",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "n = int(input())\nfor i in range(1, 11):\n  print(i * n)",
      "first_seen": 1771003817.2667384,
      "last_seen": 1771003817.2667422
    },
    "strings:7a9a8bf4": {
      "task_signature": "strings:7a9a8bf4",
      "category": "strings",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "s = input()\nprint(s[::-1])",
      "first_seen": 1771003822.0765212,
      "last_seen": 1771003822.0765243
    },
    "strings:10555a61": {
      "task_signature": "strings:10555a61",
      "category": "strings",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "s = input()\ns = s.lower()\ncount = 0\nfor char in s:\n  if char in 'aeiou':\n    count += 1\nprint(count)",
      "first_seen": 1771003827.4480083,
      "last_seen": 1771003827.4480107
    },
    "lists:f9045af9": {
      "task_signature": "lists:f9045af9",
      "category": "lists",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "n = int(input())\nnumbers = []\nfor _ in range(n):\n    numbers.append(int(input()))\n\nprint(min(numbers), max(numbers))",
      "first_seen": 1771003833.0257483,
      "last_seen": 1771003833.0257518
    },
    "functions:33a0d6c1": {
      "task_signature": "functions:33a0d6c1",
      "category": "functions",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def factorial(n):\n  if n == 0:\n    return 1\n  else:\n    result = 1\n    for i in range(1, n + 1):\n      result *= i\n    return result\n\nn = int(input())\nprint(factorial(n))",
      "first_seen": 1771003838.2299638,
      "last_seen": 1771003838.2299669
    },
    "functions:14f839d7": {
      "task_signature": "functions:14f839d7",
      "category": "functions",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "n = int(input())\nfib = [0, 1]\nif n > 2:\n    for i in range(2, n):\n        fib.append(fib[i-1] + fib[i-2])\n\nif n >= 1:\n    print(fib[0], end=\"\")\n    for i in range(1, n):\n        print(\" \" + str(fib[i]), end=\"\")\n    print()",
      "first_seen": 1771003854.274411,
      "last_seen": 1771003854.2744138
    },
    "strings:3606e008": {
      "task_signature": "strings:3606e008",
      "category": "strings",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "s = input()\nif s.lower() == s.lower()[::-1]:\n  print('yes')\nelse:\n  print('no')",
      "first_seen": 1771003860.0990987,
      "last_seen": 1771003860.0991006
    },
    "algorithms:accabcf1": {
      "task_signature": "algorithms:accabcf1",
      "category": "algorithms",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "import math\n\ndef is_prime(n):\n    if n < 2:\n        return \"not prime\"\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return \"not prime\"\n    return \"prime\"\n\nn = int(input())\nprint(is_prime(n))",
      "first_seen": 1771003879.7024307,
      "last_seen": 1771003879.7024324
    },
    "algorithms:f78bd878": {
      "task_signature": "algorithms:f78bd878",
      "category": "algorithms",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "n = int(input())\nnumbers = []\nfor _ in range(n):\n    numbers.append(int(input()))\n\nnumbers.sort()\nprint(*numbers)",
      "first_seen": 1771003885.9519231,
      "last_seen": 1771003885.9519253
    },
    "algorithms:21564de6": {
      "task_signature": "algorithms:21564de6",
      "category": "algorithms",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def binary_search(arr, target):\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return -1\n\nn = int(input())\narr = []\nfor _ in range(n):\n    arr.append(int(input()))\ntarget = int(input())\nprint(binary_search(arr, target))",
      "first_seen": 1771003894.0326,
      "last_seen": 1771003894.032602
    },
    "algorithms:7853a374": {
      "task_signature": "algorithms:7853a374",
      "category": "algorithms",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "text = input()\nwords = text.split()\nword_counts = {}\nfor word in words:\n    if word in word_counts:\n        word_counts[word] += 1\n    else:\n        word_counts[word] = 1\n\nsorted_words = sorted(word_counts.keys())\n\nfor word in sorted_words:\n    print(word, word_counts[word])",
      "first_seen": 1771003900.1645744,
      "last_seen": 1771003900.1645768
    },
    "algorithms:4aaf83f1": {
      "task_signature": "algorithms:4aaf83f1",
      "category": "algorithms",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def gcd(a, b):\n  while(b):\n    a, b = b, a % b\n  return a\n\na = int(input())\nb = int(input())\nprint(gcd(a, b))",
      "first_seen": 1771003907.0960262,
      "last_seen": 1771003907.0960283
    },
    "advanced:9aea44dc": {
      "task_signature": "advanced:9aea44dc",
      "category": "advanced",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    r, c = map(int, input().split())\n    matrix = []\n    for _ in range(r):\n        matrix.append(list(map(int, input().split())))\n    \n    transposed = [[matrix[j][i] for j in range(r)] for i in range(c)]\n    \n    for row in transposed:\n        print(*row)\n\nsolve()",
      "first_seen": 1771003914.436842,
      "last_seen": 1771003914.436844
    },
    "bugfix:ffe61cee": {
      "task_signature": "bugfix:ffe61cee",
      "category": "bugfix",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 3,
      "consecutive_successes": 3,
      "failures": 0,
      "best_code": "n = int(input())\nfor i in range(1, n+1):\n    if i % 15 == 0:\n        print(\"FizzBuzz\")\n    elif i % 3 == 0:\n        print(\"Fizz\")\n    elif i % 5 == 0:\n        print(\"Buzz\")\n    else:\n        print(i)",
      "first_seen": 1771004621.819475,
      "last_seen": 1771146529.6231816
    },
    "refactor_string_advanced:fb398753": {
      "task_signature": "refactor_string_advanced:fb398753",
      "category": "refactor_string_advanced",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 4,
      "consecutive_successes": 4,
      "failures": 0,
      "best_code": "def solve():\n    a = input()\n    b = input()\n\n    def normalize(s):\n        return sorted(filter(str.isalnum, map(str.lower, s)))\n\n    print('yes' if normalize(a) == normalize(b) else 'no')\n\nsolve()",
      "first_seen": 1771005031.8867483,
      "last_seen": 1771144444.1226585
    },
    "refactor_linked_list:5df4b1d6": {
      "task_signature": "refactor_linked_list:5df4b1d6",
      "category": "refactor_linked_list",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "def solve():\n    n = int(input())\n    nums = [int(input()) for _ in range(n)]\n\n    def find_duplicate(nums):\n        tortoise = nums[0]\n        hare = nums[0]\n        \n        # Find the intersection point of the two runners.\n        while True:\n            tortoise = nums[tortoise]\n            hare = nums[nums[hare]]\n            if tortoise == hare:\n                break\n\n        # Find the \"entrance\" to the cycle.\n        ptr1 = nums[0]\n        ptr2 = tortoise\n        while ptr1 != ptr2:\n            ptr1 = nums[ptr1]\n            ptr2 = nums[ptr2]\n\n        return ptr1\n\n    print(find_duplicate(nums))\n\nsolve()",
      "first_seen": 1771005911.5404341,
      "last_seen": 1771071102.7858775
    },
    "refactor_recursion:291416f1": {
      "task_signature": "refactor_recursion:291416f1",
      "category": "refactor_recursion",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 5,
      "consecutive_successes": 5,
      "failures": 0,
      "best_code": "def digital_root(n):\n  while n >= 10:\n    n = sum(map(int, str(n)))\n  return n\n\nx = int(input())\nprint(digital_root(x))",
      "first_seen": 1771008463.2818112,
      "last_seen": 1771141682.1117628
    },
    "refactor_data_structure:9227c0ed": {
      "task_signature": "refactor_data_structure:9227c0ed",
      "category": "refactor_data_structure",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "s = input()\nstack = []\npairs = {')': '(', ']': '[', '}': '{'}\nfor c in s:\n    if c in pairs.values():\n        stack.append(c)\n    elif c in pairs:\n        if not stack or stack.pop() != pairs[c]:\n            print('no')\n            exit()\nif stack:\n    print('no')\nelse:\n    print('yes')",
      "first_seen": 1771011143.6289322,
      "last_seen": 1771158589.284009
    },
    "refactor_matrix:5549bd37": {
      "task_signature": "refactor_matrix:5549bd37",
      "category": "refactor_matrix",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "n = int(input())\nmat = [list(map(int, input().split())) for _ in range(n)]\nprint(sum(map(lambda i: mat[i][i], range(n))))",
      "first_seen": 1771012163.4991176,
      "last_seen": 1771141682.543461
    },
    "refactor_list:4e307302": {
      "task_signature": "refactor_list:4e307302",
      "category": "refactor_list",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "n = int(input())\nnumbers = [int(input()) for _ in range(n)]\nnegative_count = len(list(filter(lambda x: x < 0, numbers)))\nprint(negative_count)",
      "first_seen": 1771012167.4041076,
      "last_seen": 1771012167.4041095
    },
    "refactor_list:7ee7b4f6": {
      "task_signature": "refactor_list:7ee7b4f6",
      "category": "refactor_list",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "n = int(input())\nnumbers = [int(input()) for _ in range(n)]\naverage = round(sum(numbers) / n)\nprint(average)",
      "first_seen": 1771012171.2347062,
      "last_seen": 1771160359.7644951
    },
    "refactor_dict:207c878e": {
      "task_signature": "refactor_dict:207c878e",
      "category": "refactor_dict",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 4,
      "consecutive_successes": 4,
      "failures": 0,
      "best_code": "s = input().replace(' ', '')\ncounts = {c: s.count(c) for c in set(s)}\nresult = [f\"{c} {counts[c]}\" for c in sorted(counts.keys())]\nprint('\\n'.join(result))",
      "first_seen": 1771013265.6910522,
      "last_seen": 1771139114.6699243
    },
    "refactor_dict:5c15066b": {
      "task_signature": "refactor_dict:5c15066b",
      "category": "refactor_dict",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 2,
      "consecutive_successes": 2,
      "failures": 0,
      "best_code": "s = input()\nwords = sorted(list(set(s.split())))\nresult = [' '.join([w, str(len(w))]) for w in words]\nprint('\\n'.join(result))",
      "first_seen": 1771015696.6612418,
      "last_seen": 1771139642.652
    },
    "refactor_list:d39c3fa2": {
      "task_signature": "refactor_list:d39c3fa2",
      "category": "refactor_list",
      "source_tier": "s2",
      "target_tier": "s1",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "n = int(input())\nnumbers = [int(input()) for _ in range(n)]\nprint(len(list(filter(lambda x: x > 0, numbers))))",
      "first_seen": 1771068467.7841094,
      "last_seen": 1771068467.784112
    },
    "refactor_graph:14b70985": {
      "task_signature": "refactor_graph:14b70985",
      "category": "refactor_graph",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 3,
      "consecutive_successes": 3,
      "failures": 0,
      "best_code": "from collections import defaultdict, deque\n\nn, m = map(int, input().split())\nadj = defaultdict(list)\nfor _ in range(m):\n    u, v = map(int, input().split())\n    adj[u].append(v)\n    adj[v].append(u)\nstart, end = map(int, input().split())\n\nvisited = {start}\nqueue = deque([start])\n\nwhile queue:\n    node = queue.popleft()\n    if node == end:\n        print('yes')\n        exit()\n    for neighbor in adj[node]:\n        if neighbor not in visited:\n            visited.add(neighbor)\n            queue.append(neighbor)\n\nprint('no')",
      "first_seen": 1771071949.0749407,
      "last_seen": 1771147680.8795233
    },
    "refactor_graph:718f74c8": {
      "task_signature": "refactor_graph:718f74c8",
      "category": "refactor_graph",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 1,
      "consecutive_successes": 1,
      "failures": 0,
      "best_code": "def solve():\n    n, m = map(int, input().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    for i in range(n):\n        print(' '.join(map(str, sorted(adj[i]))))\n\nsolve()",
      "first_seen": 1771138103.3516061,
      "last_seen": 1771138105.0969574
    },
    "refactor_string_advanced:e7296fb5": {
      "task_signature": "refactor_string_advanced:e7296fb5",
      "category": "refactor_string_advanced",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 3,
      "consecutive_successes": 3,
      "failures": 0,
      "best_code": "s = input()\nn = int(input())\nprint(''.join(chr((ord(c) - (base := ord('a') if c.islower() else ord('A')) + n) % 26 + base) if c.isalpha() else c for c in s))",
      "first_seen": 1771140901.8040228,
      "last_seen": 1771148998.3607638
    },
    "refactor_matrix:cf1a5d14": {
      "task_signature": "refactor_matrix:cf1a5d14",
      "category": "refactor_matrix",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 0,
      "consecutive_successes": 0,
      "failures": 0,
      "best_code": "",
      "first_seen": 1771141681.211814,
      "last_seen": 1771141681.2118142
    },
    "refactor_list:9a24e4aa": {
      "task_signature": "refactor_list:9a24e4aa",
      "category": "refactor_list",
      "source_tier": "s1",
      "target_tier": "s0",
      "successes": 0,
      "consecutive_successes": 0,
      "failures": 0,
      "best_code": "",
      "first_seen": 1771142478.3332918,
      "last_seen": 1771142478.3332922
    }
  }
}