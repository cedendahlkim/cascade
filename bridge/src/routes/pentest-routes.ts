import { Router } from "express";
import type { FrankensteinAgent } from "../agent-frankenstein.js";
import { getWafServiceUrl, getDefaultWafTargetBaseUrl } from "../tools-waf.js";

interface PentestWafReportRequestBody {
  run_id?: string;
  base_url?: string;
  profile?: string;
  tags?: string;
}

async function readJsonSafely(response: Response): Promise<unknown> {
  const text = await response.text();
  if (!text) return {};
  try {
    return JSON.parse(text);
  } catch {
    return { error: text };
  }
}

function truncateTests(results: unknown, limit: number): unknown {
  if (!results || typeof results !== "object") return results;
  const record = results as Record<string, unknown>;
  const tests = record.tests;
  if (!Array.isArray(tests)) return results;

  const failed = tests.filter((t) => t && typeof t === "object" && (t as any).passed === false);
  const trimmed = failed.slice(0, limit);

  return {
    ...record,
    tests: trimmed,
    _note: `Included only the first ${trimmed.length}/${failed.length} failing tests for report context.`,
  };
}

function buildWafReportPrompt(input: {
  runId: string;
  baseUrl: string;
  profile: string;
  tags: string;
  results: unknown;
}): string {
  return `Du är Frankenstein, en senior säkerhetsanalytiker.

Skapa en *pentest-rapport* baserad på WAF Hardening körningen nedan.

Krav:
- Svara i Markdown.
- Kort executive summary först.
- Lista findings (prioriterade), och koppla dem till OWASP Top 10 där möjligt.
- Föreslå konkreta mitigations (kod/konfig) och hur vi verifierar fix.
- Inkludera en "Next run"-sektion (vilka tags/ids att köra efter fix).
- Var tydlig med att detta är *WAF test corpus*-resultat, inte en full nätverks-pentest.

Context:
- run_id: ${input.runId}
- base_url: ${input.baseUrl}
- profile: ${input.profile}
- tags: ${input.tags || "(none)"}

WAF results JSON (trimmed):
${JSON.stringify(input.results, null, 2)}
`;
}

export function createPentestRoutes(frankAgent: FrankensteinAgent): Router {
  const router = Router();

  router.get("/config", (_req, res) => {
    res.json({
      waf_service_url: getWafServiceUrl(),
      default_target_base_url: getDefaultWafTargetBaseUrl(),
    });
  });

  // Generate a Markdown report for a WAF run using Frankenstein.
  router.post("/waf/report", async (req, res) => {
    const body = (req.body || {}) as PentestWafReportRequestBody;
    const runId = typeof body.run_id === "string" ? body.run_id.trim() : "";

    if (!runId) {
      return res.status(400).json({ error: "run_id is required" });
    }

    if (!frankAgent.isEnabled()) {
      return res.status(503).json({ error: "Frankenstein is not enabled (set GEMINI_API_KEY)" });
    }

    const baseUrl = typeof body.base_url === "string" && body.base_url.trim().length > 0
      ? body.base_url.trim()
      : getDefaultWafTargetBaseUrl();

    const profile = typeof body.profile === "string" && body.profile.trim().length > 0
      ? body.profile.trim()
      : "pl2";

    const tags = typeof body.tags === "string" ? body.tags.trim() : "";

    const wafBase = getWafServiceUrl();

    try {
      const wafResponse = await fetch(`${wafBase}/api/run/${encodeURIComponent(runId)}/results`, {
        method: "GET",
        signal: AbortSignal.timeout(30000),
      });

      const wafPayload = await readJsonSafely(wafResponse);
      if (!wafResponse.ok) {
        return res.status(502).json({
          error: "Failed to fetch results from WAF service",
          waf_status: wafResponse.status,
          waf_payload: wafPayload,
        });
      }

      const trimmed = truncateTests(wafPayload, 40);
      const prompt = buildWafReportPrompt({ runId, baseUrl, profile, tags, results: trimmed });
      const report = await frankAgent.respondStateless(prompt);

      return res.json({
        run_id: runId,
        report_markdown: report,
        results: trimmed,
      });
    } catch (err) {
      return res.status(500).json({ error: err instanceof Error ? err.message : String(err) });
    }
  });

  return router;
}
